var documenterSearchIndex = {"docs":
[{"location":"raytracing_tutorial.html#Ray-Tracing-with-Raycore","page":"Ray Tracing Tutorial","title":"Ray Tracing with Raycore","text":"","category":"section"},{"location":"raytracing_tutorial.html","page":"Ray Tracing Tutorial","title":"Ray Tracing Tutorial","text":"book_app # hide","category":"page"},{"location":"viewfactors_content.html#View-Factors-Analysis","page":"View Factors Analysis","title":"View Factors Analysis","text":"","category":"section"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"This example demonstrates Raycore's analysis capabilities for radiosity and illumination calculations.","category":"page"},{"location":"viewfactors_content.html#Scene-Setup","page":"View Factors Analysis","title":"Scene Setup","text":"","category":"section"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie, FileIO\n\nfunction LowSphere(radius, contact=Point3f(0); ntriangles=10)\n    return Tesselation(Sphere(contact .+ Point3f(0, 0, radius), radius), ntriangles)\nend\n\n# Create scene with multiple objects\nntriangles = 10\ns1 = LowSphere(0.5f0, Point3f(-0.5, 0.0, 0); ntriangles)\ns2 = LowSphere(0.3f0, Point3f(1, 0.5, 0); ntriangles)\ns3 = LowSphere(0.3f0, Point3f(-0.5, 1, 0); ntriangles)\ns4 = LowSphere(0.4f0, Point3f(0, 1.0, 0); ntriangles)\ncat = load(Makie.assetpath(\"cat.obj\"))\n\n# Build BVH acceleration structure\nbvh = BVH([s1, s2, s3, s4, cat])\nworld_mesh = GeometryBasics.Mesh(bvh)\n\n# Visualize the scene\nf, ax, pl = mesh(world_mesh, color=:teal, axis=(show_axis=false,))\ncenter!(ax.scene)\nf","category":"page"},{"location":"viewfactors_content.html#View-Factors","page":"View Factors Analysis","title":"View Factors","text":"","category":"section"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"View factors quantify how much each surface \"sees\" every other surface - essential for radiosity calculations.","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"# Calculate view factors between all faces\nviewf_matrix = view_factors(bvh, rays_per_triangle=1000)\n\n# Sum up total view factor per face\nviewfacts = map(i -> Float32(sum(view(viewf_matrix, :, i))), 1:length(bvh.primitives))\nN = length(world_mesh.faces)\n\n# Visualize\nper_face_vf = FaceView(viewfacts, [GLTriangleFace(i) for i in 1:N])\nviewfact_mesh = GeometryBasics.mesh(world_mesh, color=per_face_vf)\nmesh(viewfact_mesh, colormap=:turbo, shading=false,\n     lowclip=:black, colorrange=(0f0, maximum(viewfacts)),\n     axis=(show_axis=false,))","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"Higher values (warm colors) indicate faces that see more of the surrounding geometry.","category":"page"},{"location":"viewfactors_content.html#Illumination","page":"View Factors Analysis","title":"Illumination","text":"","category":"section"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"Calculate how much each face is exposed to rays from a specific viewing direction.","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"# Get camera view direction\nviewdir = normalize(ax.scene.camera.view_direction[])\n\n# Compute illumination\nillum = get_illumination(bvh, viewdir)\n\n# Visualize\npf = FaceView(illum, [GLTriangleFace(i) for i in 1:N])\nillum_mesh = GeometryBasics.mesh(world_mesh, color=pf)\nmesh(illum_mesh, colormap=[:black, :yellow], colorscale=sqrt,\n     shading=false, axis=(show_axis=false,))","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"Faces directly visible from the viewing direction show higher illumination (yellow).","category":"page"},{"location":"viewfactors_content.html#Centroid-Calculation","page":"View Factors Analysis","title":"Centroid Calculation","text":"","category":"section"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"Find the average position of visible surface points from a given direction.","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"# Calculate centroid\nhitpoints, centroid = get_centroid(bvh, viewdir)\n\n# Visualize\nf, ax, pl = mesh(world_mesh, color=(:blue, 0.5), transparency=true, axis=(show_axis=false,))\neyepos = ax.scene.camera.eyeposition[]\ndepth = map(x -> norm(x .- eyepos), hitpoints)\nmeshscatter!(ax, hitpoints, color=depth, colormap=[:gray, :black], markersize=0.01)\nmeshscatter!(ax, [centroid], color=:red, markersize=0.05)\nf","category":"page"},{"location":"viewfactors_content.html","page":"View Factors Analysis","title":"View Factors Analysis","text":"The red sphere marks the centroid - useful for camera placement and focus calculations.","category":"page"},{"location":"bvh_hit_tests_content.html#BVH-Hit-Testing:-closest_hit-vs-any_hit","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"This document tests and visualizes the difference between closest_hit and any_hit functions in the BVH implementation using the new RayIntersectionSession API.","category":"page"},{"location":"bvh_hit_tests_content.html#Test-Setup","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test Setup","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie\nusing Test\nusing Bonito\n\n# Create a simple test scene with multiple overlapping primitives\nfunction create_test_scene()\n    # Three spheres at different distances along the Z-axis\n    sphere1 = Tesselation(Sphere(Point3f(0, 0, 5), 1.0f0), 20)   # Furthest\n    sphere2 = Tesselation(Sphere(Point3f(0, 0, 3), 1.0f0), 20)   # Middle\n    sphere3 = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)   # Closest\n\n    bvh = Raycore.BVH([sphere1, sphere2, sphere3])\n    return bvh\nend\n\nbvh = create_test_scene()","category":"page"},{"location":"bvh_hit_tests_content.html#Test-1:-Single-Ray-Through-Center","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 1: Single Ray Through Center","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Test a ray through the center that passes through all three spheres.","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(Raycore.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(Raycore.any_hit, [test_ray], bvh)\n\nfig = Figure()\n\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest; axis=(; show_axis=false))\nplot(fig[1, 2], session_any; axis=(; show_axis=false))\nLabel(fig[0, 1], \"closest_hit\", fontsize=20, font=:bold, tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", fontsize=20, font=:bold, tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests_content.html#Test-2:-Multiple-Rays-from-Different-Positions","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 2: Multiple Rays from Different Positions","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Test multiple rays to ensure both functions work correctly.","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Test rays from different angles (with slight offset to avoid vertex hits)\ntest_positions = map(p-> (p = p.-0.5; Point3f(p..., -5)), rand(Point2f, 10))\n# Create rays\nrays = [Raycore.Ray(o=pos, d=Vec3f(0, 0, 1)) for pos in test_positions]\n\n# Create session\nsession_multi = RayIntersectionSession(Raycore.closest_hit, rays, bvh)\nplot(session_multi; axis=(;show_axis=false))","category":"page"},{"location":"bvh_hit_tests_content.html#Visualization:-Multiple-Rays","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Visualization: Multiple Rays","text":"","category":"section"},{"location":"bvh_hit_tests_content.html#Test-4:-Difference-Between-any*hit-and-closest*hit","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 4: Difference Between anyhit and closesthit","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Demonstrate that any_hit can return different results than closest_hit.","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Create a complex scene with overlapping geometry\n# This creates a BVH where traversal order can differ from distance order\nusing Random\nRandom.seed!(123)\n\ncomplex_spheres = []\n\n# Add some large overlapping spheres\npush!(complex_spheres, Tesselation(Sphere(Point3f(0, 0, 10), 3.0f0), 20))\npush!(complex_spheres, Tesselation(Sphere(Point3f(0.5, 0, 5), 0.5f0), 15))\npush!(complex_spheres, Tesselation(Sphere(Point3f(-0.5, 0, 15), 1.5f0), 18))\n\n# Add many small spheres to create complex BVH structure\nfor i in 1:30\n    x = randn() * 5\n    y = randn() * 5\n    z = rand(8.0:0.5:12.0)\n    r = 0.3 + rand() * 0.5\n    push!(complex_spheres, Tesselation(Sphere(Point3f(x, y, z), r), 8))\nend\n\ncomplex_bvh = Raycore.BVH(complex_spheres)\n# Test rays to find cases where any_hit differs from closest_hit\ntest_rays = map(rand(Point2f, 200)) do p  \n    p = (p .* 14f0) .- 8f0\n    Raycore.Ray(o=Point3f(p..., -5), d=Vec3f(0, 0, 1))\nend\n\nsession_closest = RayIntersectionSession(Raycore.closest_hit, test_rays, complex_bvh)\nsession_any = RayIntersectionSession(Raycore.any_hit, test_rays, complex_bvh)\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest; axis=(; show_axis=false))\nplot(fig[1, 2], session_any; axis=(; show_axis=false))\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig\n","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Key Findings:","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"any_hit exits on the first intersection during BVH traversal (uses intersect, doesn't update ray)\nclosest_hit continues searching and updates ray's t_max (uses intersect_p!)\nIn complex scenes with overlapping geometry, any_hit can return hits that are significantly farther\nBoth always agree on whether a hit occurred (hit vs miss)\nThe difference appears when BVH traversal order differs from spatial distance order","category":"page"},{"location":"bvh_hit_tests_content.html#Performance-Comparison","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Performance Comparison","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Compare the performance of closest_hit vs any_hit.","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"function render_io(obj)\n    io = IOBuffer()\n    show(io, MIME\"text/plain\"(), obj)\n    printer = BonitoBook.HTMLPrinter(io; root_tag = \"span\")\n    str = sprint(io -> show(io, MIME\"text/html\"(), printer))\n    DOM.pre(HTML(str); style=\"font-size: 10px\")\nend","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"using BenchmarkTools\n\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Benchmark closest_hit\nclosest_time = @benchmark Raycore.closest_hit($bvh, $test_ray)\n\n# Benchmark any_hit\nany_time = @benchmark Raycore.any_hit($bvh, $test_ray)\n\n\nperf_table = map([\n    (\"closest_hit\", any_time),\n    (\"any_hit\", closest_time),\n]) do (method, time_us)\n    (Method = method, Time_μs = render_io(time_us))\nend\nBonito.Table(perf_table)","category":"page"},{"location":"bvh_hit_tests_content.html#Summary","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Summary","text":"","category":"section"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"This document demonstrated:","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"RayIntersectionSession - A convenient struct for managing ray tracing sessions\nBundles rays, BVH, hit function, and results together\nProvides helper functions: hit_count(), miss_count(), hit_points(), hit_distances()\nMakie visualization recipe - Automatic visualization via plot(session)\nAutomatically renders BVH geometry, rays, and hit points\nCustomizable colors, transparency, markers, and labels\nWorks with any Makie backend (GLMakie, WGLMakie, CairoMakie)\nclosest_hit correctly identifies the nearest intersection among multiple overlapping primitives\nReturns: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\ndistance is the distance from ray origin to the hit point\nUse Raycore.sum_mul(bary_coords, primitive.vertices) to convert to world-space hit point\nany_hit efficiently determines if any intersection exists, exiting early\nReturns: Same format as closest_hit: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\nCan exit early on first hit found, making it faster for occlusion testing\nBoth functions handle miss cases correctly (returning hit_found=false)\nany_hit is typically faster than closest_hit due to early termination","category":"page"},{"location":"bvh_hit_tests_content.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"All tests passed! ✓","category":"page"},{"location":"bvh_hit_tests.html#BVH-Hit-tests","page":"BVH Hit Tests","title":"BVH Hit tests","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"book_app # hide","category":"page"},{"location":"raytracing_tutorial_content.html#Ray-Tracing-with-Raycore:-Building-a-Real-Ray-Tracer","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"In this tutorial, we'll build a simple but complete ray tracer from scratch using Raycore. We'll start with the absolute basics and progressively add features until we have a ray tracer that produces beautiful images with shadows, materials, and reflections.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"By the end, you'll have a working ray tracer that renders at interactive speeds!","category":"page"},{"location":"raytracing_tutorial_content.html#Setup","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Setup","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing Colors, ImageShow\nusing Makie  # For loading assets\nusing BenchmarkTools","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Ready to go! We have:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore for fast ray-triangle intersections\nGeometryBasics for geometry primitives\nColors and ImageShow for displaying rendered images","category":"page"},{"location":"raytracing_tutorial_content.html#Part-1:-Our-Scene,-The-Makie-Cat","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 1: Our Scene, The Makie Cat","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's create a fun scene that we'll use throughout this tutorial.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Load the cat model and rotate it to face the camera\ncat_mesh = Makie.loadasset(\"cat.obj\")\nangle = deg2rad(150f0)\nrotation = Makie.Quaternionf(0, sin(angle/2), 0, cos(angle/2))\nrotated_coords = [rotation * Point3f(v) for v in coordinates(cat_mesh)]\n\n# Get bounding box and translate cat to sit on the floor\ncat_bbox = Rect3f(rotated_coords)\nfloor_y = -1.5f0\ncat_offset = Vec3f(0, floor_y - cat_bbox.origin[2], 0)\n\ncat_mesh = GeometryBasics.normal_mesh(\n    [v + cat_offset for v in rotated_coords],\n    faces(cat_mesh)\n)\n\n# Create a simple room: floor, back wall, and side wall\nfloor = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(10, 0.01, 10)))\nback_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, 8), Vec3f(10, 5, 0.01)))\nleft_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(0.01, 5, 10)))\n\n# Add a couple of spheres for visual interest\nsphere1 = Tesselation(Sphere(Point3f(-2, -1.5 + 0.8, 2), 0.8f0), 64)\nsphere2 = Tesselation(Sphere(Point3f(2, -1.5 + 0.6, 1), 0.6f0), 64)\n\n# Build our BVH acceleration structure\nscene_geometry = [cat_mesh, floor, back_wall, left_wall, sphere1, sphere2]\nbvh = Raycore.BVH(scene_geometry)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Scene created! Cat model, room geometry, decorative spheres, and BVH for fast ray traversal.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-2:-Helper-Functions-Building-Blocks","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 2: Helper Functions - Building Blocks","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's define reusable helper functions we'll use throughout:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Compute interpolated normal at hit point\nfunction compute_normal(triangle, bary_coords)\n    v0, v1, v2 = Raycore.normals(triangle)\n    u, v, w = bary_coords[1], bary_coords[2], bary_coords[3]\n    return Vec3f(normalize(v0 * u + v1 * v + v2 * w))\nend\n\n# Generate camera ray for a pixel with optional jitter\nfunction camera_ray(x, y, width, height, camera_pos, focal_length, aspect; jitter=Vec2f(0))\n    ndc_x = (2.0f0 * (Float32(x) - 0.5f0 + jitter[1]) / Float32(width) - 1.0f0) * aspect\n    ndc_y = 1.0f0 - 2.0f0 * (Float32(y) - 0.5f0 + jitter[2]) / Float32(height)\n    direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n    return Raycore.Ray(o=camera_pos, d=direction)\nend\n\n# Convert between color representations\nto_vec3f(c::RGB) = Vec3f(c.r, c.g, c.b)\nto_rgb(v::Vec3f) = RGB{Float32}(v...)","category":"page"},{"location":"raytracing_tutorial_content.html#Part-3:-The-Simplest-Ray-Tracer-Depth-Visualization","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 3: The Simplest Ray Tracer - Depth Visualization","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function trace(f, bvh; width=700, height=300,\n               camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n               sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0),\n               samples=1, ctx=nothing)\n    img = Matrix{RGB{Float32}}(undef, height, width)\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            color_sum = Vec3f(0)\n\n            for _ in 1:samples\n                jitter = samples > 1 ? rand(Vec2f) : Vec2f(0)\n                ray = camera_ray(x, y, width, height, camera_pos, focal_length, aspect; jitter)\n                hit_found, triangle, distance, bary_coords = Raycore.closest_hit(bvh, ray)\n\n                color = if hit_found\n                    to_vec3f(f(bvh, ctx, triangle, distance, bary_coords, ray))\n                else\n                    to_vec3f(sky_color)\n                end\n                color_sum += color\n            end\n\n            img[y, x] = to_rgb(color_sum / samples)\n        end\n    end\n\n    return img\nend\n\n# Visualize depth\ndepth_kernel(bvh, ctx, tri, dist, bary, ray) = RGB(1.0f0 - min(dist / 10.0f0, 1.0f0))","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"@time trace(depth_kernel, bvh, samples=16)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"First render! Depth visualization shows distance to surfaces. Much faster with threading and smoother with multi-sampling!","category":"page"},{"location":"raytracing_tutorial_content.html#Part-5:-Lighting-with-Hard-Shadows","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 5: Lighting with Hard Shadows","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add lighting and shadows using a reusable lighting function:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Reusable lighting function with optional shadow sampling\nfunction compute_light(\n        bvh, point, normal, light_pos, light_intensity, light_color; shadow_samples=1)\n\n    light_vec = light_pos - point\n    light_dist = norm(light_vec)\n    light_dir = light_vec / light_dist\n\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Shadow testing with optional soft shadows\n    shadow_factor = 0.0f0\n    light_radius = 0.2f0  # Size of area light for soft shadows\n\n    for _ in 1:shadow_samples\n        # For shadow_samples=1, this is just the light position (hard shadow)\n        # For shadow_samples>1, we sample random points on a disk (soft shadow)\n        if shadow_samples > 1\n            # Random point on disk perpendicular to light direction\n            offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * light_radius\n            offset = offset - light_dir * dot(offset, light_dir)\n            shadow_target = light_pos + offset\n        else\n            shadow_target = light_pos\n        end\n\n        shadow_vec = shadow_target - point\n        shadow_dist = norm(shadow_vec)\n        shadow_dir = normalize(shadow_vec)\n\n        shadow_ray = Raycore.Ray(o=point + normal * 0.001f0, d=shadow_dir)\n        shadow_hit, _, hit_dist, _ = Raycore.any_hit(bvh, shadow_ray)\n\n        if !shadow_hit || hit_dist >= shadow_dist\n            shadow_factor += 1.0f0\n        end\n    end\n    shadow_factor /= shadow_samples\n\n    # Compute final light contribution\n    attenuation = light_intensity / (light_dist * light_dist)\n    return to_vec3f(light_color) * (diffuse * attenuation * shadow_factor)\nend\n\nfunction shadow_kernel(bvh, ctx, tri, dist, bary, ray; shadow_samples=1)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    # Single point light\n    light_pos = Point3f(3, 4, -2)\n    light_intensity = 50.0f0\n    light_color = RGB{Float32}(1.0f0, 0.9f0, 0.8f0)\n    # Hard shadows (shadow_samples=1)\n    light_contrib = compute_light(\n        bvh, hit_point, normal, light_pos, light_intensity, light_color;\n        shadow_samples=shadow_samples\n    )\n    ambient = 0.1f0\n\n    brightness = ambient .+ light_contrib\n    return to_rgb(brightness)\nend\n\ntrace(shadow_kernel, bvh, samples=4)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Hard shadows working! Scene has realistic lighting with sharp shadow edges.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-6:-Soft-Shadows","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 6: Soft Shadows","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now let's make shadows more realistic by sampling the light as an area light:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"trace((args...)-> shadow_kernel(args...; shadow_samples=8), bvh, samples=8)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Soft shadows! Much more realistic with smooth penumbra edges.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-7:-Materials-and-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 7: Materials and Multiple Lights","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Time to add color and multiple lights:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"struct PointLight\n    position::Point3f\n    intensity::Float32\n    color::RGB{Float32}\nend\n\nstruct Material\n    base_color::RGB{Float32}\n    metallic::Float32\n    roughness::Float32\nend\n\nstruct RenderContext\n    lights::Vector{PointLight}\n    materials::Vector{Material}\n    ambient::Float32\nend\n\n# Create lights and materials\nlights = [\n    PointLight(Point3f(3, 4, -2), 50.0f0, RGB(1.0f0, 0.9f0, 0.8f0)),\n    PointLight(Point3f(-3, 2, 0), 20.0f0, RGB(0.7f0, 0.8f0, 1.0f0)),\n    PointLight(Point3f(0, 5, 5), 15.0f0, RGB(1.0f0, 1.0f0, 1.0f0))\n]\n\nmaterials = [\n    Material(RGB(0.8f0, 0.6f0, 0.4f0), 0.0f0, 0.8f0),  # cat\n    Material(RGB(0.3f0, 0.5f0, 0.3f0), 0.0f0, 0.9f0),  # floor\n    Material(RGB(0.8f0, 0.6f0, 0.5f0), 0.8f0, 0.05f0),  # back wall\n    Material(RGB(0.7f0, 0.7f0, 0.8f0), 0.0f0, 0.8f0),  # left wall\n    Material(RGB(0.9f0, 0.9f0, 0.9f0), 0.8f0, 0.02f0),  # sphere1 - metallic\n    Material(RGB(0.3f0, 0.6f0, 0.9f0), 0.5f0, 0.3f0),  # sphere2 - semi-metallic\n]\n\nctx = RenderContext(lights, materials, 0.1f0)\nnothing","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Compute lighting from all lights - reusing our compute_light function!\nfunction compute_multi_light(bvh, ctx, point, normal, mat; shadow_samples=1)\n    base_color = to_vec3f(mat.base_color)\n    total_color = base_color * ctx.ambient\n\n    for light in ctx.lights\n        light_contrib = compute_light(bvh, point, normal, light.position, light.intensity, light.color, shadow_samples=shadow_samples)\n        total_color += base_color .* light_contrib\n    end\n\n    return total_color\nend\n\nfunction material_kernel(bvh, ctx, tri, dist, bary, ray)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    mat = ctx.materials[tri.material_idx]\n\n    color = compute_multi_light(bvh, ctx, hit_point, normal, mat, shadow_samples=2)\n    return to_rgb(color)\nend\n\ntrace(material_kernel, bvh, samples=4, ctx=ctx)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Colorful scene with soft shadows from multiple lights! Each object has its own material.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-8:-Reflections","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 8: Reflections","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Add simple reflections for metallic surfaces:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function reflective_kernel(bvh, ctx, tri, dist, bary, ray, sky_color)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    mat = ctx.materials[tri.material_idx]\n\n    # Direct lighting with soft shadows\n    direct_color = compute_multi_light(bvh, ctx, hit_point, normal, mat, shadow_samples=8)\n\n    # Reflections for metallic surfaces\n    if mat.metallic > 0.0f0\n        wo = -ray.d\n        reflect_dir = Raycore.reflect(wo, normal)\n\n        # Optional roughness\n        if mat.roughness > 0.0f0\n            offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * mat.roughness\n            reflect_dir = normalize(reflect_dir + offset)\n        end\n\n        # Cast reflection ray\n        reflect_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=reflect_dir)\n        refl_hit, refl_tri, refl_dist, refl_bary = Raycore.closest_hit(bvh, reflect_ray)\n\n        reflection_color = if refl_hit\n            refl_point = reflect_ray.o + reflect_ray.d * refl_dist\n            refl_normal = compute_normal(refl_tri, refl_bary)\n            refl_mat = ctx.materials[refl_tri.material_idx]\n            compute_multi_light(bvh, ctx, refl_point, refl_normal, refl_mat, shadow_samples=1)\n        else\n            to_vec3f(sky_color)\n        end\n\n        direct_color = direct_color * (1.0f0 - mat.metallic) + reflection_color * mat.metallic\n    end\n\n    return to_rgb(direct_color)\nend\n\nimg = trace(bvh, samples=16, ctx=ctx) do bvh, ctx, tri, dist, bary, ray\n    reflective_kernel(bvh, ctx, tri, dist, bary, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Tone mapping functions\nluminosity(c::RGB{T}) where {T} = (max(c.r, c.g, c.b) + min(c.r, c.g, c.b)) / 2.0f0\n\nfunction avg_lum(rgb_m, δ::Number=1f-10)\n    cumsum = 0.0f0\n    for pix in rgb_m\n        cumsum += log10(δ + luminosity(pix))\n    end\n    return 10^(cumsum / (prod(size(rgb_m))))\nend\n\nfunction tone_mapping(img; a=0.5f0, y=1.0f0, lum=avg_lum(img, 1f-10))\n    img_normalized = img .* a .* (1.0f0 / lum)\n    img_01 = map(col->mapc(c-> clamp(c, 0f0, 1f0), col), img_normalized)\n    ycorrected = map(col->mapc(c-> c^(1f0 / y), col), img_01)\n    return ycorrected\nend\n\ntone_mapping(img, a=0.38, y=1.0)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using JET\n\n# Get test data\ntest_ray = camera_ray(350, 150, 700, 300, Point3f(0, -0.9, -2.5), 1.0f0 / tan(deg2rad(45.0f0 / 2)), Float32(700/300))\nhit_found, test_tri, test_dist, test_bary = Raycore.closest_hit(bvh, test_ray)\n\n# Check kernel type stability (filter to Main module to ignore Base internals)\n@test_opt target_modules=(Main,) depth_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) shadow_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) material_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) reflective_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray, RGB(0.5f0, 0.7f0, 1.0f0))\nnothing","category":"page"},{"location":"raytracing_tutorial_content.html#Summary","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Summary","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"We built a complete ray tracer with:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Core Features:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"BVH acceleration for fast ray-scene intersections\nPerspective camera with configurable FOV\nSmooth shading from interpolated normals\nMulti-light system with distance attenuation\nSoft shadows using area light sampling (via compute_light with shadow_samples)\nMaterial system (base color, metallic, roughness)\nReflections with optional roughness\nACES tone mapping for HDR","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Performance:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Multi-threading for parallel rendering (introduced early!)\nMulti-sampling for anti-aliasing (introduced early!)\nType-stable kernels for optimal performance\nModular, reusable compute_light function - works for both hard and soft shadows","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Key Raycore Functions:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore.BVH(meshes) - Build acceleration structure\nRaycore.Ray(o=origin, d=direction) - Create ray\nRaycore.closest_hit(bvh, ray) - Find nearest intersection\nRaycore.any_hit(bvh, ray) - Test for any intersection\nRaycore.reflect(wo, normal) - Compute reflection direction","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Key Pattern: The compute_light function is reusable across the entire tutorial:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"shadow_samples=1 → hard shadows\nshadow_samples=4 → soft shadows","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"This shows how a well-designed function can handle multiple use cases cleanly!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Happy ray tracing!","category":"page"},{"location":"gpu_raytracing_tutorial.html#GPU-Ray-Tracing-with-Raycore","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"In this tutorial, we'll take the ray tracer from the previous tutorial and port it to the GPU using KernelAbstractions.jl and a GPU backend of choice (CUDA.jl, AMDGPU.jl, OpenCL.jl, OneApi.jl, or Metal.jl). We'll explore three different kernel implementations, each with different optimization strategies, and benchmark their performance against each other.","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"By the end, you'll understand how to write efficient GPU kernels for ray tracing and the tradeoffs between different approaches!","category":"page"},{"location":"gpu_raytracing_tutorial.html#Setup","page":"GPU Ray Tracing with Raycore","title":"Setup","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing Colors, ImageShow\nusing WGLMakie\nusing KernelAbstractions\nusing BenchmarkTools","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"To run things on the GPU with KernelAbstractions, you need to chose the correct package for your GPU and set the array type we use from there on.","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"#using CUDA; GArray = CuArray; # For NVIDIA GPUS\n#using AMDGPU; GArray = ROCArray; # for AMD GPUs\n#using Metal; GArray = MtlArray; # for Apple hardware\n#using oneAPI; GArray = oneArray; # for intel\n# OpenCL with the pocl backend should work for most CPUs and some GPUs, but might not be as fast.\n# using pocl_jll, OpenCL; GArray = CLArray;\nGArray = Array # For the tutorial to run on CI we just use the CPU","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Ready for GPU! We have:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Raycore for fast ray-triangle intersections\nKernelAbstractions for portable GPU kernels\nAMDGPU for AMD GPU support\nBenchmarkTools for performance comparison","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-1:-Scene-Setup-(Same-as-CPU-Tutorial)","page":"GPU Ray Tracing with Raycore","title":"Part 1: Scene Setup (Same as CPU Tutorial)","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Let's use the exact same scene as the CPU tutorial - the Makie cat with room geometry:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"# Load and prepare the cat model\ninclude(\"raytracing-core.jl\")\nbvh, ctx = example_scene()\n# We have a Makie extension for plotting the scene graph\nf, ax, pl = plot(bvh; axis=(; show_axis=false))\nf","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"cam = cameracontrols(ax.scene)\ncam.eyeposition[] = [0, 1.0, -5]\ncam.lookat[] = [0, 0, 2]\ncam.upvector[] = [0.0, 1, 0.0]\ncam.fov[] = 45.0","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-5:-GPU-Kernel-Version-1-Basic-Naive-Approach","page":"GPU Ray Tracing with Raycore","title":"Part 5: GPU Kernel Version 1 - Basic Naive Approach","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"The simplest GPU kernel - one thread per pixel:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"import KernelAbstractions as KA\n\n# Basic kernel: one thread per pixel, straightforward implementation\n@kernel function raytrace_kernel_v1!(\n    img, @Const(bvh), @Const(ctx),\n    camera_pos, focal_length, aspect, sky_color, ::Val{NSamples}\n) where {NSamples}\n    # Get pixel coordinates\n    idx = @index(Global, Linear)\n    height, width = size(img)\n    # Convert linear index to 2D coordinates\n    x = ((idx - 1) % width) + 1\n    y = ((idx - 1) ÷ width) + 1\n    if x <= width && y <= height\n        # Generate camera ray and do a calculate a simple light model\n        color = Vec3f(0)\n        for i in 1:NSamples\n            color = color .+ sample_light(bvh, ctx, width, height, camera_pos, focal_length, aspect, x, y, sky_color)\n        end\n        @inbounds img[y, x] = to_rgb(color ./ NSamples)\n    end\nend","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"The trace_gpu function is a universal launcher that works with any of our kernels. It handles the backend-specific setup automatically using KernelAbstractions.jl:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"function trace_gpu(kernel, img, bvh, ctx;\n        camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n        sky_color=RGB{Float32}(0.5f0,0.7f0,1.0f0),\n        samples_per_pixel=4,\n        ndrange=length(img), tilesize=nothing\n    )\n    height, width = size(img)\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    # KernelAbstractions automatically detects the backend (CPU/GPU) from the array type\n    backend = KA.get_backend(img)\n\n    # Create the kernel with or without tilesize (for workgroup configuration)\n    kernel! = isnothing(tilesize) ? kernel(backend) : kernel(backend, tilesize)\n\n    kernel!(img, bvh, ctx, camera_pos, focal_length, aspect, sky_color, Val(samples_per_pixel), ndrange=ndrange)\n\n    # Ensure GPU computation completes before returning\n    KA.synchronize(backend)\n    return img\nend","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Key KernelAbstractions.jl concepts:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Backend detection: get_backend(array) automatically determines if we're using CPU, AMD GPU, NVIDIA GPU, etc.\nKernel compilation: kernel(backend) compiles the kernel for the specific backend\nWorkgroup configuration: Optional tilesize parameter controls thread organization\nThread indexing: Inside kernels, use @index(Global, Linear) or @index(Global, Cartesian) to get thread IDs\nSynchronization: synchronize(backend) ensures all GPU work completes before continuing","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Let's test kernel v1 on the CPU (yes, they always work with normal Arrays):","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"img = fill(RGBf(0, 0, 0), 400, 720)\nbench_kernel_cpu_v1 = @benchmark trace_gpu(raytrace_kernel_v1!, img, bvh, ctx)\nimg","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"To run things on the GPU, we simply convert the arrays to the GPU backend array type. to_gpu is a helper in Raycore to convert nested structs correctly for the kernel. It's not doing anything special, besides that struct of arrays need to be converted to device arrays and for pure arrays GPUArray(array) is enough.","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"using Raycore: to_gpu\nimg = fill(RGBf(0, 0, 0), 400, 720)\nimg_gpu = GArray(img);\nbvh_gpu = to_gpu(GArray, bvh);\nctx_gpu = to_gpu(GArray, ctx);\nbench_kernel_v1 = @benchmark trace_gpu(raytrace_kernel_v1!, img_gpu, bvh_gpu, ctx_gpu)\n# bring back to GPU to display image\nArray(img_gpu)","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"First GPU render! This is the simplest approach - one thread per pixel with no optimization.","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-6:-Optimized-Kernel-Loop-Unrolling","page":"GPU Ray Tracing with Raycore","title":"Part 6: Optimized Kernel - Loop Unrolling","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Loop overhead is significant on GPUs! Manually unrolling the sampling loop eliminates this overhead:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"# Optimized kernel: Unrolled sampling loop\n@kernel function raytrace_kernel_unrolled!(\n        img, @Const(bvh), @Const(ctx),\n        camera_pos, focal_length, aspect, sky_color, ::Val{NSamples}\n    ) where {NSamples}\n    idx = @index(Global, Linear)\n    height, width = size(img)\n    x = ((idx - 1) % width) + 1\n    y = ((idx - 1) ÷ width) + 1\n    if x <= width && y <= height\n        # ntuple with compile-time constant for unrolling\n        samples = ntuple(NSamples) do i\n            sample_light(bvh, ctx, width, height,\n                camera_pos, focal_length, aspect,\n                x, y, sky_color\n            )\n        end\n        color = mean(samples)\n        @inbounds img[y, x] = to_rgb(color)\n    end\nend\n\nbench_kernel_unrolled = @benchmark trace_gpu(raytrace_kernel_unrolled!, img_gpu, bvh_gpu, ctx_gpu)\nArray(img_gpu)","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"This eliminates branch overhead from loop conditions\nReduces register pressure\nBetter instruction-level parallelism\n1.39x faster than baseline!","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-7:-Tiled-Kernel-with-Optimized-Tile-Size","page":"GPU Ray Tracing with Raycore","title":"Part 7: Tiled Kernel with Optimized Tile Size","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"The tile size dramatically affects performance. Let's use the optimal size discovered through benchmarking:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"# Tiled kernel with optimized tile size\n@kernel function raytrace_kernel_tiled!(\n    img, bvh, ctx,\n    camera_pos, focal_length, aspect, sky_color, ::Val{NSamples}\n) where {NSamples}\n    # Get tile and local coordinates\n    _tile_xy = @index(Group, Cartesian)\n    _local_xy = @index(Local, Cartesian)\n    _groupsize = @groupsize()\n\n    # Direct tuple unpacking is faster than Vec construction\n    tile_x, tile_y = Tuple(_tile_xy)\n    local_x, local_y = Tuple(_local_xy)\n    group_w, group_h = _groupsize\n\n    # Compute global pixel coordinates\n    x = (tile_x - 1) * group_w + local_x\n    y = (tile_y - 1) * group_h + local_y\n\n    height, width = size(img)\n    if x <= width && y <= height\n        samples = ntuple(NSamples) do i\n            sample_light(bvh, ctx, width, height,\n                camera_pos, focal_length, aspect,\n                x, y, sky_color\n            )\n        end\n        color = mean(samples)\n        @inbounds img[y, x] = to_rgb(color)\n    end\nend\nbench_kernel_tiled_32_16 = @benchmark trace_gpu(\n    $raytrace_kernel_tiled!, $img_gpu, $bvh_gpu, $ctx_gpu;\n    ndrange=size($img_gpu), tilesize=(32,16))\n\n# Benchmark two more important tile sizes for comparison\nbench_kernel_tiled_32_32 = @benchmark trace_gpu(\n    $raytrace_kernel_tiled!, $img_gpu, $bvh_gpu, $ctx_gpu;\n    ndrange=size($img_gpu), tilesize=(32,32))\n\nbench_kernel_tiled_8_8 = @benchmark trace_gpu(\n    $raytrace_kernel_tiled!, $img_gpu, $bvh_gpu, $ctx_gpu;\n    ndrange=size($img_gpu), tilesize=(8,8))\n\n# Use optimal tile size: (32, 16) - discovered through benchmarking!\nArray(img_gpu)","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Tile size matters! With (32, 16) tiles, this kernel is 1.22x faster than baseline. With poor tile sizes like (8, 8), it can be 2.5x slower!","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-8:-Wavefront-Path-Tracing","page":"GPU Ray Tracing with Raycore","title":"Part 8: Wavefront Path Tracing","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"The wavefront approach reorganizes ray tracing to minimize thread divergence by grouping similar work together. Instead of each thread handling an entire pixel's path, we separate the work into stages. Discussing the excat implementation is outside the scope of this tutorial, so we only include the finished renderer here:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"include(\"wavefront-renderer.jl\")","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Let's benchmark the wavefront renderer on both CPU and GPU:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"# CPU benchmark\nrenderer_cpu = WavefrontRenderer(img, bvh, ctx)\nbench_wavefront_cpu = @benchmark render!($renderer_cpu)\n\n# GPU benchmark\nrenderer_gpu = to_gpu(GArray, renderer_cpu)\nbench_wavefront_gpu = @benchmark render!($renderer_gpu)\n\nrenderer_gpu = to_gpu(GArray, WavefrontRenderer(img, bvh, ctx; samples_per_pixel=16))\nrender!(renderer_gpu)\n# Display result\nArray(renderer_gpu.framebuffer)","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Wavefront benefits:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Reduces thread divergence by grouping similar work\nBetter memory access patterns\nScales well with scene complexity\nEnables advanced features like path tracing","category":"page"},{"location":"gpu_raytracing_tutorial.html#Part-9:-Comprehensive-Performance-Benchmarks","page":"GPU Ray Tracing with Raycore","title":"Part 9: Comprehensive Performance Benchmarks","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Now let's compare all kernels including the wavefront renderer:","category":"page"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"benchmarks = [\n    bench_kernel_v1, bench_kernel_cpu_v1, bench_kernel_unrolled,\n    bench_kernel_tiled_8_8, bench_kernel_tiled_32_16, bench_kernel_tiled_32_32,\n    bench_wavefront_cpu, bench_wavefront_gpu\n]\nlabels = [\n    \"Baseline\\n(gpu)\", \"Baseline\\n(cpu)\", \"Unrolled\",\n    \"Tiled\\n(8×8)\", \"Tiled\\n(32×16)\", \"Tiled\\n(32×32)\",\n    \"Wavefront\\n(cpu)\", \"Wavefront\\n(gpu)\"\n]\n\nfig, times, speedups = plot_kernel_benchmarks(benchmarks, labels)\n# save(data\"gpu-benchmarks.png\", fig; backend=Main.GLMakie)\n# We use the Fig from my local run, since on CI this won't show the differences\nDOM.img(src=Asset(data\"gpu-benchmarks.png\"), width=\"700px\")","category":"page"},{"location":"gpu_raytracing_tutorial.html#Next-Steps","page":"GPU Ray Tracing with Raycore","title":"Next Steps","text":"","category":"section"},{"location":"gpu_raytracing_tutorial.html","page":"GPU Ray Tracing with Raycore","title":"GPU Ray Tracing with Raycore","text":"Add adaptive sampling (more samples only where needed)\nExplore shared memory optimizations for BVH traversal\nImplement streaming multisampling across frames\nTry persistent threads with dynamic work distribution","category":"page"},{"location":"viewfactors.html#View-Factors-and-More","page":"View Factors and More","title":"View Factors and More","text":"","category":"section"},{"location":"viewfactors.html","page":"View Factors and More","title":"View Factors and More","text":"book_app # hide","category":"page"},{"location":"gpu_raytracing.html#GPU-Ray-Tracing-with-Raycore","page":"GPU Ray Tracing Tutorial","title":"GPU Ray Tracing with Raycore","text":"","category":"section"},{"location":"gpu_raytracing.html","page":"GPU Ray Tracing Tutorial","title":"GPU Ray Tracing Tutorial","text":"book_app # hide","category":"page"},{"location":"index.html#Raycore.jl","page":"Home","title":"Raycore.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"High-performance ray-triangle intersection engine with BVH acceleration for CPU and GPU.","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Fast BVH acceleration for ray-triangle intersection\nCPU and GPU support via KernelAbstractions.jl\nAnalysis tools: centroid calculation, illumination analysis, view factors for radiosity\nMakie integration for visualization","category":"page"},{"location":"index.html#Interactive-Examples","page":"Home","title":"Interactive Examples","text":"","category":"section"},{"location":"index.html#BVH-Hit-Tests-and-Basics","page":"Home","title":"BVH Hit Tests & Basics","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Learn the basics of ray-triangle intersection, BVH construction, and visualization.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: BVH Basics)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"BVH Hit tests","category":"page"},{"location":"index.html#Ray-Tracing-Tutorial","page":"Home","title":"Ray Tracing Tutorial","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Build a complete ray tracer from scratch with shadows, materials, reflections, and tone mapping.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Ray Tracing)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Ray Tracing with Raycore","category":"page"},{"location":"index.html#View-Factors-Analysis","page":"Home","title":"View Factors Analysis","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Calculate view factors, illumination, and centroids for radiosity and thermal analysis.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: View Factors)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"View Factors and More","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#Raycore.BVH","page":"Home","title":"Raycore.BVH","text":"BVH{NodeVec, TriVec, OrigTriVec}\n\nGPU-optimized BVH acceleration structure.\n\nKey optimizations:\n\nUses LinearBVH node structure (flat array, depth-first layout)\nPre-transforms triangles with edge vectors for Möller-Trumbore\nDesigned for efficient GPU kernel traversal\n\nFields:\n\nnodes: LinearBVH nodes (flat array, depth-first layout)\ntriangles: Pre-transformed compact triangles\noriginal_triangles: Original triangles (for normals, UVs, materials)\nmaxnodeprimitives: Maximum primitives per leaf node\n\n\n\n\n\n","category":"type"},{"location":"index.html#Raycore.BVH-Union{Tuple{AbstractVector{P}}, Tuple{P}, Tuple{AbstractVector{P}, Integer}} where P","page":"Home","title":"Raycore.BVH","text":"BVH(primitives::AbstractVector, max_node_primitives::Integer=1)\n\nConstruct a BVH acceleration structure from a list of primitives (meshes or geometries).\n\nArguments:\n\nprimitives: Vector of triangle meshes or GeometryBasics geometries\nmax_node_primitives: Maximum number of primitives per leaf node (default: 1)\n\nReturns a GPU-optimized BVH with pre-transformed triangles for efficient ray tracing.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.RayIntersectionSession","page":"Home","title":"Raycore.RayIntersectionSession","text":"RayIntersectionSession{F}\n\nRepresents a ray tracing session containing rays, a BVH structure, a hit function, and the computed intersection results.\n\nFields\n\nrays::Vector{<:AbstractRay}: Array of rays to trace\nbvh::BVH: BVH acceleration structure to intersect against\nhit_function::F: Function to use for intersection testing (e.g., closest_hit or any_hit)\nhits::Vector{Tuple{Bool, Triangle, Float32, Point3f}}: Results of hit_function applied to each ray\n\nExample\n\nusing Raycore, GeometryBasics\n\n# Create BVH from geometry\nsphere = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)\nbvh = Raycore.BVH([sphere])\n\n# Create rays\nrays = [\n    Raycore.Ray(Point3f(0, 0, -5), Vec3f(0, 0, 1)),\n    Raycore.Ray(Point3f(1, 0, -5), Vec3f(0, 0, 1)),\n]\n\n# Create session\nsession = RayIntersectionSession(rays, bvh, Raycore.closest_hit)\n\n# Access results\nfor (i, hit) in enumerate(session.hits)\n    hit_found, primitive, distance, bary_coords = hit\n    if hit_found\n        println(\"Ray $i hit at distance $distance\")\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"index.html#Raycore.any_hit","page":"Home","title":"Raycore.any_hit","text":"any_hit(bvh::BVH, ray::AbstractRay)\n\nTest if a ray intersects any primitive in the GPU BVH (for occlusion testing). Stops at the first intersection found.\n\nReturns:\n\nhit_found: Boolean indicating if any intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"function"},{"location":"index.html#Raycore.closest_hit","page":"Home","title":"Raycore.closest_hit","text":"closest_hit(bvh::BVH, ray::AbstractRay)\n\nFind the closest intersection between a ray and the GPU BVH. Uses manual traversal with compact triangle intersection for best performance.\n\nReturns:\n\nhit_found: Boolean indicating if an intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"function"},{"location":"index.html#Raycore.hit_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_count","text":"hit_count(session::RayIntersectionSession)\n\nCount the number of rays that hit geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_distances-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_distances","text":"hit_distances(session::RayIntersectionSession)\n\nExtract all hit distances from a RayIntersectionSession.\n\nReturns a vector of Float32 containing distances for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_points-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_points","text":"hit_points(session::RayIntersectionSession)\n\nExtract all valid hit points from a RayIntersectionSession.\n\nReturns a vector of Point3f containing the world-space hit points for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.miss_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.miss_count","text":"miss_count(session::RayIntersectionSession)\n\nCount the number of rays that missed all geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.reflect","text":"Reflect wo about n.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Private-Functions","page":"Home","title":"Private Functions","text":"","category":"section"},{"location":"index.html#Raycore.CompactTriangle","page":"Home","title":"Raycore.CompactTriangle","text":"CompactTriangle\n\nPre-transformed triangle data for efficient GPU ray-triangle intersection. Uses edge vectors for Möller-Trumbore intersection algorithm.\n\nFields:\n\nv0: First vertex position (4th component for alignment)\nedge1: v1 - v0 edge vector\nedge2: v2 - v0 edge vector\nnormal: Face normal (4th component for alignment)\nindices: [materialidx, primitiveidx] for shading\n\n\n\n\n\n","category":"type"},{"location":"index.html#Raycore.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.cos_θ","text":"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.\n\nSince normal is (0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.face_forward-Tuple{Any, Any}","page":"Home","title":"Raycore.face_forward","text":"Flip normal n so that it lies in the same hemisphere as v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.generate_ray_grid-Tuple{BVH, GeometryBasics.Vec{3, Float32}, Int64}","page":"Home","title":"Raycore.generate_ray_grid","text":"generate_ray_grid(bvh::BVH, ray_direction::Vec3f, grid_size::Int)\n\nGenerate a grid of ray origins based on the BVH bounding box and a given ray direction.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.intersect_compact_triangle-Tuple{Raycore.CompactTriangle, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}","page":"Home","title":"Raycore.intersect_compact_triangle","text":"intersect_compact_triangle(tri::CompactTriangle, ray_o, ray_d, t_max)\n\nWatertight Möller-Trumbore ray-triangle intersection for GPU. Uses pre-computed edge vectors for efficiency.\n\nReturns: (hit, t, u, v) where u,v are barycentric coordinates\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.intersect_p-Tuple{Bounds3, Raycore.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}","page":"Home","title":"Raycore.intersect_p","text":"dirisnegative: 1 – false, 2 – true\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.maximum_extent-Tuple{Bounds3}","page":"Home","title":"Raycore.maximum_extent","text":"Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.\n\n1 - x, 2 - y, 3 - z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.offset-Tuple{Bounds3, GeometryBasics.Point{3, Float32}}","page":"Home","title":"Raycore.offset","text":"Get offset of a point from the minimum point of the bounds.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.to_compact_triangle-Tuple{Triangle}","page":"Home","title":"Raycore.to_compact_triangle","text":"to_compact_triangle(tri::Triangle) -> CompactTriangle\n\nConvert a Triangle to CompactTriangle format with pre-computed edge vectors.\n\n\n\n\n\n","category":"method"}]
}
