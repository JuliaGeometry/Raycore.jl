var documenterSearchIndex = {"docs":
[{"location":"raytracing_tutorial.html#Ray-Tracing-with-Raycore","page":"Ray Tracing Tutorial","title":"Ray Tracing with Raycore","text":"","category":"section"},{"location":"raytracing_tutorial.html","page":"Ray Tracing Tutorial","title":"Ray Tracing Tutorial","text":"using Bonito, BonitoBook, Raycore\nApp() do\n    path = normpath(joinpath(dirname(pathof(Raycore)), \"..\", \"docs\", \"src\", \"raytracing_tutorial_content.md\"))\n    BonitoBook.InlineBook(path)\nend","category":"page"},{"location":"bvh_hit_tests.html#BVH-Hit-Testing:-closest_hit-vs-any_hit","page":"BVH Hit Tests","title":"BVH Hit Testing: closest_hit vs any_hit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"This document tests and visualizes the difference between closest_hit and any_hit functions in the BVH implementation using the new RayIntersectionSession API.","category":"page"},{"location":"bvh_hit_tests.html#Test-Setup","page":"BVH Hit Tests","title":"Test Setup","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie\nusing Test\nusing Bonito\n\n# Create a simple test scene with multiple overlapping primitives\nfunction create_test_scene()\n    # Three spheres at different distances along the Z-axis\n    sphere1 = Tesselation(Sphere(Point3f(0, 0, 5), 1.0f0), 20)   # Furthest\n    sphere2 = Tesselation(Sphere(Point3f(0, 0, 3), 1.0f0), 20)   # Middle\n    sphere3 = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)   # Closest\n\n    bvh = Raycore.BVHAccel([sphere1, sphere2, sphere3])\n    return bvh\nend\n\nbvh = create_test_scene()\n\nDOM.div(\"✓ Created BVH with $(length(bvh.primitives)) triangles from 3 spheres\")","category":"page"},{"location":"bvh_hit_tests.html#Test-1:-Single-Ray-Through-Center","page":"BVH Hit Tests","title":"Test 1: Single Ray Through Center","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Test a ray through the center that passes through all three spheres.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(Raycore.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(Raycore.any_hit, [test_ray], bvh)\n\nfig = Figure()\n\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", fontsize=20, font=:bold, tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", fontsize=20, font=:bold, tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Single-Ray-with-Makie-Recipe","page":"BVH Hit Tests","title":"Visualization: Single Ray with Makie Recipe","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, 10), d=Vec3f(0, 0, -1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(Raycore.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(Raycore.any_hit, [test_ray], bvh)\n\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Test-2:-Multiple-Rays-from-Different-Positions","page":"BVH Hit Tests","title":"Test 2: Multiple Rays from Different Positions","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Test multiple rays to ensure both functions work correctly.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Test rays from different angles (with slight offset to avoid vertex hits)\ntest_positions = [\n    Point3f(0.1, 0.1, -5),      # Center\n    Point3f(0.5, 0.1, -5),      # Right offset\n    Point3f(0.1, 0.5, -5),      # Top offset\n    Point3f(-0.5, 0.1, -5),     # Left offset\n]\n\n# Create rays\nrays = [Raycore.Ray(o=pos, d=Vec3f(0, 0, 1)) for pos in test_positions]\n\n# Create session\nsession_multi = RayIntersectionSession(Raycore.closest_hit, rays, bvh)\nfig2 = Figure()\nax = LScene(fig2[1, 1])\n\n# Use different colors for each ray\nray_colors = [:purple, :orange, :cyan, :magenta]\n\nplot!(ax, session_multi;\n      show_bvh=true,\n      bvh_alpha=0.3,\n      ray_colors=ray_colors,\n      hit_color=:green,\n      show_hit_points=true,\n      hit_markersize=0.15,\n      show_labels=false)\n\nfig2","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Multiple-Rays","page":"BVH Hit Tests","title":"Visualization: Multiple Rays","text":"","category":"section"},{"location":"bvh_hit_tests.html#Test-4:-Difference-Between-any*hit-and-closest*hit","page":"BVH Hit Tests","title":"Test 4: Difference Between anyhit and closesthit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Demonstrate that any_hit can return different results than closest_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a complex scene with overlapping geometry\n# This creates a BVH where traversal order can differ from distance order\nusing Random\nRandom.seed!(123)\n\ncomplex_spheres = []\n\n# Add some large overlapping spheres\npush!(complex_spheres, Tesselation(Sphere(Point3f(0, 0, 10), 3.0f0), 20))\npush!(complex_spheres, Tesselation(Sphere(Point3f(0.5, 0, 5), 0.5f0), 15))\npush!(complex_spheres, Tesselation(Sphere(Point3f(-0.5, 0, 15), 1.5f0), 18))\n\n# Add many small spheres to create complex BVH structure\nfor i in 1:30\n    x = randn() * 5\n    y = randn() * 5\n    z = rand(8.0:0.5:12.0)\n    r = 0.3 + rand() * 0.5\n    push!(complex_spheres, Tesselation(Sphere(Point3f(x, y, z), r), 8))\nend\n\ncomplex_bvh = Raycore.BVHAccel(complex_spheres)\n\n# Test rays to find cases where any_hit differs from closest_hit\ntest_rays = map(1:100) do i\n    x = (i % 10) * 0.4 - 2.0\n    y = div(i-1, 10) * 0.4 - 2.0\n    Raycore.Ray(o=Point3f(x, y, -5), d=Vec3f(0, 0, 1))\nend\n\nsession_closest = RayIntersectionSession(Raycore.closest_hit, test_rays, complex_bvh)\nsession_any = RayIntersectionSession(Raycore.any_hit, test_rays, complex_bvh)\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig\n","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Key Findings:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"any_hit exits on the first intersection during BVH traversal (uses intersect, doesn't update ray)\nclosest_hit continues searching and updates ray's t_max (uses intersect_p!)\nIn complex scenes with overlapping geometry, any_hit can return hits that are significantly farther\nBoth always agree on whether a hit occurred (hit vs miss)\nThe difference appears when BVH traversal order differs from spatial distance order","category":"page"},{"location":"bvh_hit_tests.html#Performance-Comparison","page":"BVH Hit Tests","title":"Performance Comparison","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Compare the performance of closest_hit vs any_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"function render_io(obj)\n    io = IOBuffer()\n    show(io, MIME\"text/plain\"(), obj)\n    printer = BonitoBook.HTMLPrinter(io; root_tag = \"span\")\n    str = sprint(io -> show(io, MIME\"text/html\"(), printer))\n    DOM.pre(HTML(str); style=\"font-size: 10px\")\nend","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"using BenchmarkTools\n\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Benchmark closest_hit\nclosest_time = @benchmark Raycore.closest_hit($bvh, $test_ray)\n\n# Benchmark any_hit\nany_time = @benchmark Raycore.any_hit($bvh, $test_ray)\n\n\nperf_table = map([\n    (\"closest_hit\", any_time),\n    (\"any_hit\", closest_time),\n]) do (method, time_us)\n    (Method = method, Time_μs = render_io(time_us))\nend\nBonito.Table(perf_table)","category":"page"},{"location":"bvh_hit_tests.html#Summary","page":"BVH Hit Tests","title":"Summary","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"This document demonstrated:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"RayIntersectionSession - A convenient struct for managing ray tracing sessions\nBundles rays, BVH, hit function, and results together\nProvides helper functions: hit_count(), miss_count(), hit_points(), hit_distances()\nMakie visualization recipe - Automatic visualization via plot(session)\nAutomatically renders BVH geometry, rays, and hit points\nCustomizable colors, transparency, markers, and labels\nWorks with any Makie backend (GLMakie, WGLMakie, CairoMakie)\nclosest_hit correctly identifies the nearest intersection among multiple overlapping primitives\nReturns: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\ndistance is the distance from ray origin to the hit point\nUse Raycore.sum_mul(bary_coords, primitive.vertices) to convert to world-space hit point\nany_hit efficiently determines if any intersection exists, exiting early\nReturns: Same format as closest_hit: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\nCan exit early on first hit found, making it faster for occlusion testing\nBoth functions handle miss cases correctly (returning hit_found=false)\nany_hit is typically faster than closest_hit due to early termination","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"All tests passed! ✓","category":"page"},{"location":"raytracing_tutorial_content.html#Ray-Tracing-with-Raycore:-Building-a-Real-Ray-Tracer","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"In this tutorial, we'll build a simple but complete ray tracer from scratch using Raycore. We'll start with the absolute basics and progressively add features until we have a ray tracer that produces beautiful images with shadows, materials, and reflections.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"By the end, you'll have a working ray tracer that renders at interactive speeds!","category":"page"},{"location":"raytracing_tutorial_content.html#Setup","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Setup","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing Colors, ImageShow\nusing Makie  # For loading assets\nusing BenchmarkTools","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Ready to go! We have:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore for fast ray-triangle intersections\nGeometryBasics for geometry primitives\nColors and ImageShow for displaying rendered images","category":"page"},{"location":"raytracing_tutorial_content.html#Part-1:-Our-Scene,-The-Makie-Cat","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 1: Our Scene, The Makie Cat","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's create a fun scene that we'll use throughout this tutorial.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Load the cat model and rotate it to face the camera\ncat_mesh = Makie.loadasset(\"cat.obj\")\nangle = deg2rad(150f0)\nrotation = Makie.Quaternionf(0, sin(angle/2), 0, cos(angle/2))\nrotated_coords = [rotation * Point3f(v) for v in coordinates(cat_mesh)]\n\n# Get bounding box and translate cat to sit on the floor\ncat_bbox = Rect3f(rotated_coords)\nfloor_y = -1.5f0\ncat_offset = Vec3f(0, floor_y - cat_bbox.origin[2], 0)\n\ncat_mesh = GeometryBasics.normal_mesh(\n    [v + cat_offset for v in rotated_coords],\n    faces(cat_mesh)\n)\n\n# Create a simple room: floor, back wall, and side wall\nfloor = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(10, 0.01, 10)))\nback_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, 8), Vec3f(10, 5, 0.01)))\nleft_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(0.01, 5, 10)))\n\n# Add a couple of spheres for visual interest\nsphere1 = Tesselation(Sphere(Point3f(-2, -1.5 + 0.8, 2), 0.8f0), 64)\nsphere2 = Tesselation(Sphere(Point3f(2, -1.5 + 0.6, 1), 0.6f0), 64)\n\n# Build our BVH acceleration structure\nscene_geometry = [cat_mesh, floor, back_wall, left_wall, sphere1, sphere2]\nbvh = Raycore.BVHAccel(scene_geometry)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Scene created! Cat model, room geometry, decorative spheres, and BVH for fast ray traversal.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-2:-Helper-Functions-Building-Blocks","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 2: Helper Functions - Building Blocks","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's define reusable helper functions we'll use throughout:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Compute interpolated normal at hit point\nfunction compute_normal(triangle, bary_coords)\n    v0, v1, v2 = Raycore.normals(triangle)\n    u, v, w = bary_coords[1], bary_coords[2], bary_coords[3]\n    return Vec3f(normalize(v0 * u + v1 * v + v2 * w))\nend\n\n# Generate camera ray for a pixel with optional jitter\nfunction camera_ray(x, y, width, height, camera_pos, focal_length, aspect; jitter=Vec2f(0))\n    ndc_x = (2.0f0 * (Float32(x) - 0.5f0 + jitter[1]) / Float32(width) - 1.0f0) * aspect\n    ndc_y = 1.0f0 - 2.0f0 * (Float32(y) - 0.5f0 + jitter[2]) / Float32(height)\n    direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n    return Raycore.Ray(o=camera_pos, d=direction)\nend\n\n# Convert between color representations\nto_vec3f(c::RGB) = Vec3f(c.r, c.g, c.b)\nto_rgb(v::Vec3f) = RGB{Float32}(v...)","category":"page"},{"location":"raytracing_tutorial_content.html#Part-3:-The-Simplest-Ray-Tracer-Depth-Visualization","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 3: The Simplest Ray Tracer - Depth Visualization","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function trace(f, bvh; width=700, height=300,\n               camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n               sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0),\n               samples=1, ctx=nothing)\n    img = Matrix{RGB{Float32}}(undef, height, width)\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            color_sum = Vec3f(0)\n\n            for _ in 1:samples\n                jitter = samples > 1 ? rand(Vec2f) : Vec2f(0)\n                ray = camera_ray(x, y, width, height, camera_pos, focal_length, aspect; jitter)\n                hit_found, triangle, distance, bary_coords = Raycore.closest_hit(bvh, ray)\n\n                color = if hit_found\n                    to_vec3f(f(bvh, ctx, triangle, distance, bary_coords, ray))\n                else\n                    to_vec3f(sky_color)\n                end\n                color_sum += color\n            end\n\n            img[y, x] = to_rgb(color_sum / samples)\n        end\n    end\n\n    return img\nend\n\n# Visualize depth\ndepth_kernel(bvh, ctx, tri, dist, bary, ray) = RGB(1.0f0 - min(dist / 10.0f0, 1.0f0))","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"@time trace(depth_kernel, bvh, samples=16)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"First render! Depth visualization shows distance to surfaces. Much faster with threading and smoother with multi-sampling!","category":"page"},{"location":"raytracing_tutorial_content.html#Part-5:-Lighting-with-Hard-Shadows","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 5: Lighting with Hard Shadows","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add lighting and shadows using a reusable lighting function:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Reusable lighting function with optional shadow sampling\nfunction compute_light(\n        bvh, point, normal, light_pos, light_intensity, light_color; shadow_samples=1)\n\n    light_vec = light_pos - point\n    light_dist = norm(light_vec)\n    light_dir = light_vec / light_dist\n\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Shadow testing with optional soft shadows\n    shadow_factor = 0.0f0\n    light_radius = 0.2f0  # Size of area light for soft shadows\n\n    for _ in 1:shadow_samples\n        # For shadow_samples=1, this is just the light position (hard shadow)\n        # For shadow_samples>1, we sample random points on a disk (soft shadow)\n        if shadow_samples > 1\n            # Random point on disk perpendicular to light direction\n            offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * light_radius\n            offset = offset - light_dir * dot(offset, light_dir)\n            shadow_target = light_pos + offset\n        else\n            shadow_target = light_pos\n        end\n\n        shadow_vec = shadow_target - point\n        shadow_dist = norm(shadow_vec)\n        shadow_dir = normalize(shadow_vec)\n\n        shadow_ray = Raycore.Ray(o=point + normal * 0.001f0, d=shadow_dir)\n        shadow_hit, _, hit_dist, _ = Raycore.any_hit(bvh, shadow_ray)\n\n        if !shadow_hit || hit_dist >= shadow_dist\n            shadow_factor += 1.0f0\n        end\n    end\n    shadow_factor /= shadow_samples\n\n    # Compute final light contribution\n    attenuation = light_intensity / (light_dist * light_dist)\n    return to_vec3f(light_color) * (diffuse * attenuation * shadow_factor)\nend\n\nfunction shadow_kernel(bvh, ctx, tri, dist, bary, ray; shadow_samples=1)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    # Single point light\n    light_pos = Point3f(3, 4, -2)\n    light_intensity = 50.0f0\n    light_color = RGB{Float32}(1.0f0, 0.9f0, 0.8f0)\n    # Hard shadows (shadow_samples=1)\n    light_contrib = compute_light(\n        bvh, hit_point, normal, light_pos, light_intensity, light_color;\n        shadow_samples=shadow_samples\n    )\n    ambient = 0.1f0\n\n    brightness = ambient .+ light_contrib\n    return to_rgb(brightness)\nend\n\ntrace(shadow_kernel, bvh, samples=4)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Hard shadows working! Scene has realistic lighting with sharp shadow edges.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-6:-Soft-Shadows","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 6: Soft Shadows","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now let's make shadows more realistic by sampling the light as an area light:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"trace((args...)-> shadow_kernel(args...; shadow_samples=8), bvh, samples=8)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Soft shadows! Much more realistic with smooth penumbra edges.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-7:-Materials-and-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 7: Materials and Multiple Lights","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Time to add color and multiple lights:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"struct PointLight\n    position::Point3f\n    intensity::Float32\n    color::RGB{Float32}\nend\n\nstruct Material\n    base_color::RGB{Float32}\n    metallic::Float32\n    roughness::Float32\nend\n\nstruct RenderContext\n    lights::Vector{PointLight}\n    materials::Vector{Material}\n    ambient::Float32\nend\n\n# Create lights and materials\nlights = [\n    PointLight(Point3f(3, 4, -2), 50.0f0, RGB(1.0f0, 0.9f0, 0.8f0)),\n    PointLight(Point3f(-3, 2, 0), 20.0f0, RGB(0.7f0, 0.8f0, 1.0f0)),\n    PointLight(Point3f(0, 5, 5), 15.0f0, RGB(1.0f0, 1.0f0, 1.0f0))\n]\n\nmaterials = [\n    Material(RGB(0.8f0, 0.6f0, 0.4f0), 0.0f0, 0.8f0),  # cat\n    Material(RGB(0.3f0, 0.5f0, 0.3f0), 0.0f0, 0.9f0),  # floor\n    Material(RGB(0.8f0, 0.6f0, 0.5f0), 0.8f0, 0.05f0),  # back wall\n    Material(RGB(0.7f0, 0.7f0, 0.8f0), 0.0f0, 0.8f0),  # left wall\n    Material(RGB(0.9f0, 0.9f0, 0.9f0), 0.8f0, 0.02f0),  # sphere1 - metallic\n    Material(RGB(0.3f0, 0.6f0, 0.9f0), 0.5f0, 0.3f0),  # sphere2 - semi-metallic\n]\n\nctx = RenderContext(lights, materials, 0.1f0)\nnothing","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Compute lighting from all lights - reusing our compute_light function!\nfunction compute_multi_light(bvh, ctx, point, normal, mat; shadow_samples=1)\n    base_color = to_vec3f(mat.base_color)\n    total_color = base_color * ctx.ambient\n\n    for light in ctx.lights\n        light_contrib = compute_light(bvh, point, normal, light.position, light.intensity, light.color, shadow_samples=shadow_samples)\n        total_color += base_color .* light_contrib\n    end\n\n    return total_color\nend\n\nfunction material_kernel(bvh, ctx, tri, dist, bary, ray)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    mat = ctx.materials[tri.material_idx]\n\n    color = compute_multi_light(bvh, ctx, hit_point, normal, mat, shadow_samples=2)\n    return to_rgb(color)\nend\n\ntrace(material_kernel, bvh, samples=4, ctx=ctx)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Colorful scene with soft shadows from multiple lights! Each object has its own material.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-8:-Reflections","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 8: Reflections","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Add simple reflections for metallic surfaces:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function reflective_kernel(bvh, ctx, tri, dist, bary, ray, sky_color)\n    hit_point = ray.o + ray.d * dist\n    normal = compute_normal(tri, bary)\n    mat = ctx.materials[tri.material_idx]\n\n    # Direct lighting with soft shadows\n    direct_color = compute_multi_light(bvh, ctx, hit_point, normal, mat, shadow_samples=8)\n\n    # Reflections for metallic surfaces\n    if mat.metallic > 0.0f0\n        wo = -ray.d\n        reflect_dir = Raycore.reflect(wo, normal)\n\n        # Optional roughness\n        if mat.roughness > 0.0f0\n            offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * mat.roughness\n            reflect_dir = normalize(reflect_dir + offset)\n        end\n\n        # Cast reflection ray\n        reflect_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=reflect_dir)\n        refl_hit, refl_tri, refl_dist, refl_bary = Raycore.closest_hit(bvh, reflect_ray)\n\n        reflection_color = if refl_hit\n            refl_point = reflect_ray.o + reflect_ray.d * refl_dist\n            refl_normal = compute_normal(refl_tri, refl_bary)\n            refl_mat = ctx.materials[refl_tri.material_idx]\n            compute_multi_light(bvh, ctx, refl_point, refl_normal, refl_mat, shadow_samples=1)\n        else\n            to_vec3f(sky_color)\n        end\n\n        direct_color = direct_color * (1.0f0 - mat.metallic) + reflection_color * mat.metallic\n    end\n\n    return to_rgb(direct_color)\nend\n\nimg = trace(bvh, samples=16, ctx=ctx) do bvh, ctx, tri, dist, bary, ray\n    reflective_kernel(bvh, ctx, tri, dist, bary, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Tone mapping functions\nluminosity(c::RGB{T}) where {T} = (max(c.r, c.g, c.b) + min(c.r, c.g, c.b)) / 2.0f0\n\nfunction avg_lum(rgb_m, δ::Number=1f-10)\n    cumsum = 0.0f0\n    for pix in rgb_m\n        cumsum += log10(δ + luminosity(pix))\n    end\n    return 10^(cumsum / (prod(size(rgb_m))))\nend\n\nfunction tone_mapping(img; a=0.5f0, y=1.0f0, lum=avg_lum(img, 1f-10))\n    img_normalized = img .* a .* (1.0f0 / lum)\n    img_01 = map(col->mapc(c-> clamp(c, 0f0, 1f0), col), img_normalized)\n    ycorrected = map(col->mapc(c-> c^(1f0 / y), col), img_01)\n    return ycorrected\nend\n\ntone_mapping(img, a=0.38, y=1.0)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using JET\n\n# Get test data\ntest_ray = camera_ray(350, 150, 700, 300, Point3f(0, -0.9, -2.5), 1.0f0 / tan(deg2rad(45.0f0 / 2)), Float32(700/300))\nhit_found, test_tri, test_dist, test_bary = Raycore.closest_hit(bvh, test_ray)\n\n# Check kernel type stability (filter to Main module to ignore Base internals)\n@test_opt target_modules=(Main,) depth_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) shadow_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) material_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray)\n@test_opt target_modules=(Main,) reflective_kernel(bvh, ctx, test_tri, test_dist, test_bary, test_ray, RGB(0.5f0, 0.7f0, 1.0f0))\nnothing","category":"page"},{"location":"raytracing_tutorial_content.html#Summary","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Summary","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"We built a complete ray tracer with:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Core Features:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"BVH acceleration for fast ray-scene intersections\nPerspective camera with configurable FOV\nSmooth shading from interpolated normals\nMulti-light system with distance attenuation\nSoft shadows using area light sampling (via compute_light with shadow_samples)\nMaterial system (base color, metallic, roughness)\nReflections with optional roughness\nACES tone mapping for HDR","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Performance:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Multi-threading for parallel rendering (introduced early!)\nMulti-sampling for anti-aliasing (introduced early!)\nType-stable kernels for optimal performance\nModular, reusable compute_light function - works for both hard and soft shadows","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Key Raycore Functions:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore.BVHAccel(meshes) - Build acceleration structure\nRaycore.Ray(o=origin, d=direction) - Create ray\nRaycore.closest_hit(bvh, ray) - Find nearest intersection\nRaycore.any_hit(bvh, ray) - Test for any intersection\nRaycore.reflect(wo, normal) - Compute reflection direction","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Key Pattern: The compute_light function is reusable across the entire tutorial:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"shadow_samples=1 → hard shadows\nshadow_samples=4 → soft shadows","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"This shows how a well-designed function can handle multiple use cases cleanly!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Happy ray tracing!","category":"page"},{"location":"index.html#Raycore.jl","page":"Home","title":"Raycore.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie, FileIO\n\nfunction LowSphere(radius, contact=Point3f(0); ntriangles=10)\n    return Tesselation(Sphere(contact .+ Point3f(0, 0, radius), radius), ntriangles)\nend\n\nntriangles = 10\ns1 = LowSphere(0.5f0, Point3f(-0.5, 0.0, 0); ntriangles)\ns2 = LowSphere(0.3f0, Point3f(1, 0.5, 0); ntriangles)\ns3 = LowSphere(0.3f0, Point3f(-0.5, 1, 0); ntriangles)\ns4 = LowSphere(0.4f0, Point3f(0, 1.0, 0); ntriangles)\nl = 0.5\nfloor = Rect3f(-l, -l, -0.01, 2l, 2l, 0.01)\ncat = load(Makie.assetpath(\"cat.obj\"))\nbvh = Raycore.BVHAccel([s1, s2, s3, s4, cat]);\nworld_mesh = GeometryBasics.Mesh(bvh)\nf, ax, pl = Makie.mesh(world_mesh; color=:teal)\ncenter!(ax.scene)\nviewdir = normalize(ax.scene.camera.view_direction[])\n\n@time \"hitpoints\" hitpoints, centroid = Raycore.get_centroid(bvh, viewdir)\n@time \"illum\" illum = Raycore.get_illumination(bvh, viewdir)\n@time \"viewf_matrix\" viewf_matrix = Raycore.view_factors(bvh, rays_per_triangle=1000)\nviewfacts = map(i-> Float32(sum(view(viewf_matrix, :, i))), 1:length(bvh.primitives))\nworld_mesh = GeometryBasics.Mesh(bvh)\nN = length(world_mesh.faces)\nareas = map(i-> area(world_mesh.position[world_mesh.faces[i]]), 1:N)\n# View factors\nf, ax, pl = mesh(world_mesh, color=:teal, figure=(; size=(800, 600)), axis=(; show_axis=false))\nper_face_vf = FaceView((viewfacts), [GLTriangleFace(i) for i in 1:N])\nviewfact_mesh = GeometryBasics.mesh(world_mesh, color=per_face_vf)\npl = Makie.mesh(f[1, 2],\n    viewfact_mesh, colormap=[:black, :red], axis=(; show_axis=false),\n    shading=false, highclip=:red, lowclip=:black, colorscale=sqrt,)\n\n# Centroid\ncax, pl = Makie.mesh(f[2, 1], world_mesh, color=(:blue, 0.5), axis=(; show_axis=false), transparency=true)\n\neyepos = cax.scene.camera.eyeposition[]\ndepth = map(x-> norm(x .- eyepos), hitpoints)\nmeshscatter!(cax, hitpoints, color=depth, colormap=[:gray, :black], markersize=0.01)\nmeshscatter!(cax, centroid, color=:red, markersize=0.05)\n\n# Illum\npf = FaceView(100f0 .* (illum ./ areas), [GLTriangleFace(i) for i in 1:N])\nillum_mesh = GeometryBasics.mesh(world_mesh, color=pf)\n\nMakie.mesh(f[2, 2], illum_mesh, colormap=[:black, :yellow], colorscale=sqrt, shading=false, axis=(; show_axis=false))\n\nLabel(f[0, 1], \"Scene ($(length(bvh.primitives)) triangles)\", tellwidth=false, fontsize=20)\nLabel(f[0, 2], \"Viewfactors\", tellwidth=false, fontsize=20)\nLabel(f[3, 1], \"Centroid\", tellwidth=false, fontsize=20)\nLabel(f[3, 2], \"Illumination\", tellwidth=false, fontsize=20)\n\nf","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Bonito, BonitoBook\nApp() do\n    path = normpath(joinpath(dirname(pathof(Raycore)), \"..\", \"docs\", \"src\", \"bvh_hit_tests.md\"))\n    BonitoBook.InlineBook(path)\nend","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#Raycore.RayIntersectionSession","page":"Home","title":"Raycore.RayIntersectionSession","text":"RayIntersectionSession{F}\n\nRepresents a ray tracing session containing rays, a BVH structure, a hit function, and the computed intersection results.\n\nFields\n\nrays::Vector{<:AbstractRay}: Array of rays to trace\nbvh::BVHAccel: BVH acceleration structure to intersect against\nhit_function::F: Function to use for intersection testing (e.g., closest_hit or any_hit)\nhits::Vector{Tuple{Bool, Triangle, Float32, Point3f}}: Results of hit_function applied to each ray\n\nExample\n\nusing Raycore, GeometryBasics\n\n# Create BVH from geometry\nsphere = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)\nbvh = Raycore.BVHAccel([sphere])\n\n# Create rays\nrays = [\n    Raycore.Ray(Point3f(0, 0, -5), Vec3f(0, 0, 1)),\n    Raycore.Ray(Point3f(1, 0, -5), Vec3f(0, 0, 1)),\n]\n\n# Create session\nsession = RayIntersectionSession(rays, bvh, Raycore.closest_hit)\n\n# Access results\nfor (i, hit) in enumerate(session.hits)\n    hit_found, primitive, distance, bary_coords = hit\n    if hit_found\n        println(\"Ray $i hit at distance $distance\")\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"index.html#Raycore.hit_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_count","text":"hit_count(session::RayIntersectionSession)\n\nCount the number of rays that hit geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_distances-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_distances","text":"hit_distances(session::RayIntersectionSession)\n\nExtract all hit distances from a RayIntersectionSession.\n\nReturns a vector of Float32 containing distances for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_points-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_points","text":"hit_points(session::RayIntersectionSession)\n\nExtract all valid hit points from a RayIntersectionSession.\n\nReturns a vector of Point3f containing the world-space hit points for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.miss_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.miss_count","text":"miss_count(session::RayIntersectionSession)\n\nCount the number of rays that missed all geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Private-Functions","page":"Home","title":"Private Functions","text":"","category":"section"},{"location":"index.html#Raycore.any_hit","page":"Home","title":"Raycore.any_hit","text":"any_hit(bvh::BVHAccel, ray::AbstractRay)\n\nTest if a ray intersects any primitive in the BVH (without finding the closest hit). This function stops at the first intersection found, making it faster than closest_hit when you only need to know if there's an intersection.\n\nReturns:\n\nhit_found: Boolean indicating if any intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"function"},{"location":"index.html#Raycore.closest_hit-Union{Tuple{P}, Tuple{Raycore.BVHAccel{P}, Raycore.AbstractRay}, Tuple{Raycore.BVHAccel{P}, Raycore.AbstractRay, Any}} where P","page":"Home","title":"Raycore.closest_hit","text":"closest_hit(bvh::BVHAccel{P}, ray::AbstractRay) where {P}\n\nFind the closest intersection between a ray and the primitives stored in a BVH.\n\nReturns:\n\nhit_found: Boolean indicating if an intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.cos_θ","text":"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.\n\nSince normal is (0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.face_forward-Tuple{Any, Any}","page":"Home","title":"Raycore.face_forward","text":"Flip normal n so that it lies in the same hemisphere as v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.generate_ray_grid-Tuple{Raycore.BVHAccel, GeometryBasics.Vec{3, Float32}, Int64}","page":"Home","title":"Raycore.generate_ray_grid","text":"generate_ray_grid(bvh::BVHAccel, ray_direction::Vec3f, grid_size::Int)\n\nGenerate a grid of ray origins based on the BVH bounding box and a given ray direction.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.intersect_p-Tuple{Raycore.Bounds3, Raycore.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}","page":"Home","title":"Raycore.intersect_p","text":"dirisnegative: 1 – false, 2 – true\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.maximum_extent-Tuple{Raycore.Bounds3}","page":"Home","title":"Raycore.maximum_extent","text":"Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.\n\n1 - x, 2 - y, 3 - z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.offset-Tuple{Raycore.Bounds3, GeometryBasics.Point{3, Float32}}","page":"Home","title":"Raycore.offset","text":"Get offset of a point from the minimum point of the bounds.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.reflect","text":"Reflect wo about n.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.traverse_bvh-Union{Tuple{F}, Tuple{P}, Tuple{F, Raycore.BVHAccel{P}, Raycore.AbstractRay}, Tuple{F, Raycore.BVHAccel{P}, Raycore.AbstractRay, Any}} where {P, F<:Function}","page":"Home","title":"Raycore.traverse_bvh","text":"traverse_bvh(bvh::BVHAccel{P}, ray::AbstractRay, hit_callback::F) where {P, F<:Function}\n\nInternal function that traverses the BVH to find ray-primitive intersections. Uses a callback pattern to handle different intersection behaviors.\n\nArguments:\n\nbvh: The BVH acceleration structure\nray: The ray to test for intersections\nhit_callback: Function called when primitive is tested. Signature:  hitcallback(primitive, ray) -> (continuetraversal::Bool, ray::AbstractRay, results::Any)\n\nReturns:\n\nThe final result from the hit_callback\n\n\n\n\n\n","category":"method"}]
}
