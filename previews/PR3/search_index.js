var documenterSearchIndex = {"docs":
[{"location":"bvh_hit_tests.html#BVH-Hit-Testing:-closest_hit-vs-any_hit","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"This document tests and visualizes the difference between closest_hit and any_hit functions in the BVH implementation using the new RayIntersectionSession API.","category":"page"},{"location":"bvh_hit_tests.html#Test-Setup","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test Setup","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"using RayCaster, GeometryBasics, LinearAlgebra\nusing WGLMakie\nusing Test\nusing Bonito\n\n# Create a simple test scene with multiple overlapping primitives\nfunction create_test_scene()\n    # Three spheres at different distances along the Z-axis\n    sphere1 = Tesselation(Sphere(Point3f(0, 0, 5), 1.0f0), 20)   # Furthest\n    sphere2 = Tesselation(Sphere(Point3f(0, 0, 3), 1.0f0), 20)   # Middle\n    sphere3 = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)   # Closest\n\n    bvh = RayCaster.BVHAccel([sphere1, sphere2, sphere3])\n    return bvh\nend\n\nbvh = create_test_scene()\n\nDOM.div(\"✓ Created BVH with $(length(bvh.primitives)) triangles from 3 spheres\")","category":"page"},{"location":"bvh_hit_tests.html#Test-1:-Single-Ray-Through-Center","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 1: Single Ray Through Center","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Test a ray through the center that passes through all three spheres.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = RayCaster.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(RayCaster.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(RayCaster.any_hit, [test_ray], bvh)\n\nfig = Figure()\n\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", fontsize=20, font=:bold, tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", fontsize=20, font=:bold, tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Single-Ray-with-Makie-Recipe","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Visualization: Single Ray with Makie Recipe","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = RayCaster.Ray(o=Point3f(0.1, 0.1, 10), d=Vec3f(0, 0, -1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(RayCaster.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(RayCaster.any_hit, [test_ray], bvh)\n\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Test-2:-Multiple-Rays-from-Different-Positions","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 2: Multiple Rays from Different Positions","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Test multiple rays to ensure both functions work correctly.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Test rays from different angles (with slight offset to avoid vertex hits)\ntest_positions = [\n    Point3f(0.1, 0.1, -5),      # Center\n    Point3f(0.5, 0.1, -5),      # Right offset\n    Point3f(0.1, 0.5, -5),      # Top offset\n    Point3f(-0.5, 0.1, -5),     # Left offset\n]\n\n# Create rays\nrays = [RayCaster.Ray(o=pos, d=Vec3f(0, 0, 1)) for pos in test_positions]\n\n# Create session\nsession_multi = RayIntersectionSession(RayCaster.closest_hit, rays, bvh)\nfig2 = Figure()\nax = LScene(fig2[1, 1])\n\n# Use different colors for each ray\nray_colors = [:purple, :orange, :cyan, :magenta]\n\nplot!(ax, session_multi;\n      show_bvh=true,\n      bvh_alpha=0.3,\n      ray_colors=ray_colors,\n      hit_color=:green,\n      show_hit_points=true,\n      hit_markersize=0.15,\n      show_labels=false)\n\nfig2","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Multiple-Rays","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Visualization: Multiple Rays","text":"","category":"section"},{"location":"bvh_hit_tests.html#Test-4:-Difference-Between-any*hit-and-closest*hit","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Test 4: Difference Between anyhit and closesthit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Demonstrate that any_hit can return different results than closest_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"# Create a complex scene with overlapping geometry\n# This creates a BVH where traversal order can differ from distance order\nusing Random\nRandom.seed!(123)\n\ncomplex_spheres = []\n\n# Add some large overlapping spheres\npush!(complex_spheres, Tesselation(Sphere(Point3f(0, 0, 10), 3.0f0), 20))\npush!(complex_spheres, Tesselation(Sphere(Point3f(0.5, 0, 5), 0.5f0), 15))\npush!(complex_spheres, Tesselation(Sphere(Point3f(-0.5, 0, 15), 1.5f0), 18))\n\n# Add many small spheres to create complex BVH structure\nfor i in 1:30\n    x = randn() * 5\n    y = randn() * 5\n    z = rand(8.0:0.5:12.0)\n    r = 0.3 + rand() * 0.5\n    push!(complex_spheres, Tesselation(Sphere(Point3f(x, y, z), r), 8))\nend\n\ncomplex_bvh = RayCaster.BVHAccel(complex_spheres)\n\n# Test rays to find cases where any_hit differs from closest_hit\ntest_rays = map(1:100) do i\n    x = (i % 10) * 0.4 - 2.0\n    y = div(i-1, 10) * 0.4 - 2.0\n    RayCaster.Ray(o=Point3f(x, y, -5), d=Vec3f(0, 0, 1))\nend\n\nsession_closest = RayIntersectionSession(RayCaster.closest_hit, test_rays, complex_bvh)\nsession_any = RayIntersectionSession(RayCaster.any_hit, test_rays, complex_bvh)\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig\n","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Key Findings:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"any_hit exits on the first intersection during BVH traversal (uses intersect, doesn't update ray)\nclosest_hit continues searching and updates ray's t_max (uses intersect_p!)\nIn complex scenes with overlapping geometry, any_hit can return hits that are significantly farther\nBoth always agree on whether a hit occurred (hit vs miss)\nThe difference appears when BVH traversal order differs from spatial distance order","category":"page"},{"location":"bvh_hit_tests.html#Performance-Comparison","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Performance Comparison","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"Compare the performance of closest_hit vs any_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"function render_io(obj)\n    io = IOBuffer()\n    show(io, MIME\"text/plain\"(), obj)\n    printer = BonitoBook.HTMLPrinter(io; root_tag = \"span\")\n    str = sprint(io -> show(io, MIME\"text/html\"(), printer))\n    DOM.pre(HTML(str); style=\"font-size: 10px\")\nend","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"using BenchmarkTools\n\ntest_ray = RayCaster.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Benchmark closest_hit\nclosest_time = @benchmark RayCaster.closest_hit($bvh, $test_ray)\n\n# Benchmark any_hit\nany_time = @benchmark RayCaster.any_hit($bvh, $test_ray)\n\n\nperf_table = map([\n    (\"closest_hit\", any_time),\n    (\"any_hit\", closest_time),\n]) do (method, time_us)\n    (Method = method, Time_μs = render_io(time_us))\nend\nBonito.Table(perf_table)","category":"page"},{"location":"bvh_hit_tests.html#Summary","page":"BVH Hit Testing: closest_hit vs any_hit","title":"Summary","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"This document demonstrated:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"RayIntersectionSession - A convenient struct for managing ray tracing sessions\nBundles rays, BVH, hit function, and results together\nProvides helper functions: hit_count(), miss_count(), hit_points(), hit_distances()\nMakie visualization recipe - Automatic visualization via plot(session)\nAutomatically renders BVH geometry, rays, and hit points\nCustomizable colors, transparency, markers, and labels\nWorks with any Makie backend (GLMakie, WGLMakie, CairoMakie)\nclosest_hit correctly identifies the nearest intersection among multiple overlapping primitives\nReturns: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\ndistance is the distance from ray origin to the hit point\nUse RayCaster.sum_mul(bary_coords, primitive.vertices) to convert to world-space hit point\nany_hit efficiently determines if any intersection exists, exiting early\nReturns: Same format as closest_hit: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\nCan exit early on first hit found, making it faster for occlusion testing\nBoth functions handle miss cases correctly (returning hit_found=false)\nany_hit is typically faster than closest_hit due to early termination","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Testing: closest_hit vs any_hit","title":"BVH Hit Testing: closest_hit vs any_hit","text":"All tests passed! ✓","category":"page"},{"location":"index.html#RayCaster.jl","page":"Home","title":"RayCaster.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using RayCaster, GeometryBasics, LinearAlgebra\nusing WGLMakie, FileIO\n\nfunction LowSphere(radius, contact=Point3f(0); ntriangles=10)\n    return Tesselation(Sphere(contact .+ Point3f(0, 0, radius), radius), ntriangles)\nend\n\nntriangles = 10\ns1 = LowSphere(0.5f0, Point3f(-0.5, 0.0, 0); ntriangles)\ns2 = LowSphere(0.3f0, Point3f(1, 0.5, 0); ntriangles)\ns3 = LowSphere(0.3f0, Point3f(-0.5, 1, 0); ntriangles)\ns4 = LowSphere(0.4f0, Point3f(0, 1.0, 0); ntriangles)\nl = 0.5\nfloor = Rect3f(-l, -l, -0.01, 2l, 2l, 0.01)\ncat = load(Makie.assetpath(\"cat.obj\"))\nbvh = RayCaster.BVHAccel([s1, s2, s3, s4, cat]);\nworld_mesh = GeometryBasics.Mesh(bvh)\nf, ax, pl = Makie.mesh(world_mesh; color=:teal)\ncenter!(ax.scene)\nviewdir = normalize(ax.scene.camera.view_direction[])\n\n@time \"hitpoints\" hitpoints, centroid = RayCaster.get_centroid(bvh, viewdir)\n@time \"illum\" illum = RayCaster.get_illumination(bvh, viewdir)\n@time \"viewf_matrix\" viewf_matrix = RayCaster.view_factors(bvh, rays_per_triangle=1000)\nviewfacts = map(i-> Float32(sum(view(viewf_matrix, :, i))), 1:length(bvh.primitives))\nworld_mesh = GeometryBasics.Mesh(bvh)\nN = length(world_mesh.faces)\nareas = map(i-> area(world_mesh.position[world_mesh.faces[i]]), 1:N)\n# View factors\nf, ax, pl = mesh(world_mesh, color=:teal, figure=(; size=(800, 600)), axis=(; show_axis=false))\nper_face_vf = FaceView((viewfacts), [GLTriangleFace(i) for i in 1:N])\nviewfact_mesh = GeometryBasics.mesh(world_mesh, color=per_face_vf)\npl = Makie.mesh(f[1, 2],\n    viewfact_mesh, colormap=[:black, :red], axis=(; show_axis=false),\n    shading=false, highclip=:red, lowclip=:black, colorscale=sqrt,)\n\n# Centroid\ncax, pl = Makie.mesh(f[2, 1], world_mesh, color=(:blue, 0.5), axis=(; show_axis=false), transparency=true)\n\neyepos = cax.scene.camera.eyeposition[]\ndepth = map(x-> norm(x .- eyepos), hitpoints)\nmeshscatter!(cax, hitpoints, color=depth, colormap=[:gray, :black], markersize=0.01)\nmeshscatter!(cax, centroid, color=:red, markersize=0.05)\n\n# Illum\npf = FaceView(100f0 .* (illum ./ areas), [GLTriangleFace(i) for i in 1:N])\nillum_mesh = GeometryBasics.mesh(world_mesh, color=pf)\n\nMakie.mesh(f[2, 2], illum_mesh, colormap=[:black, :yellow], colorscale=sqrt, shading=false, axis=(; show_axis=false))\n\nLabel(f[0, 1], \"Scene ($(length(bvh.primitives)) triangles)\", tellwidth=false, fontsize=20)\nLabel(f[0, 2], \"Viewfactors\", tellwidth=false, fontsize=20)\nLabel(f[3, 1], \"Centroid\", tellwidth=false, fontsize=20)\nLabel(f[3, 2], \"Illumination\", tellwidth=false, fontsize=20)\n\nf","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Bonito, BonitoBook\nApp() do\n    path = normpath(joinpath(dirname(pathof(RayCaster)), \"..\", \"docs\", \"src\", \"bvh_hit_tests.md\"))\n    BonitoBook.InlineBook(path)\nend","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#RayCaster.RayIntersectionSession","page":"Home","title":"RayCaster.RayIntersectionSession","text":"RayIntersectionSession{F}\n\nRepresents a ray tracing session containing rays, a BVH structure, a hit function, and the computed intersection results.\n\nFields\n\nrays::Vector{<:AbstractRay}: Array of rays to trace\nbvh::BVHAccel: BVH acceleration structure to intersect against\nhit_function::F: Function to use for intersection testing (e.g., closest_hit or any_hit)\nhits::Vector{Tuple{Bool, Triangle, Float32, Point3f}}: Results of hit_function applied to each ray\n\nExample\n\nusing RayCaster, GeometryBasics\n\n# Create BVH from geometry\nsphere = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)\nbvh = RayCaster.BVHAccel([sphere])\n\n# Create rays\nrays = [\n    RayCaster.Ray(Point3f(0, 0, -5), Vec3f(0, 0, 1)),\n    RayCaster.Ray(Point3f(1, 0, -5), Vec3f(0, 0, 1)),\n]\n\n# Create session\nsession = RayIntersectionSession(rays, bvh, RayCaster.closest_hit)\n\n# Access results\nfor (i, hit) in enumerate(session.hits)\n    hit_found, primitive, distance, bary_coords = hit\n    if hit_found\n        println(\"Ray $i hit at distance $distance\")\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"index.html#RayCaster.hit_count-Tuple{RayIntersectionSession}","page":"Home","title":"RayCaster.hit_count","text":"hit_count(session::RayIntersectionSession)\n\nCount the number of rays that hit geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.hit_distances-Tuple{RayIntersectionSession}","page":"Home","title":"RayCaster.hit_distances","text":"hit_distances(session::RayIntersectionSession)\n\nExtract all hit distances from a RayIntersectionSession.\n\nReturns a vector of Float32 containing distances for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.hit_points-Tuple{RayIntersectionSession}","page":"Home","title":"RayCaster.hit_points","text":"hit_points(session::RayIntersectionSession)\n\nExtract all valid hit points from a RayIntersectionSession.\n\nReturns a vector of Point3f containing the world-space hit points for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.miss_count-Tuple{RayIntersectionSession}","page":"Home","title":"RayCaster.miss_count","text":"miss_count(session::RayIntersectionSession)\n\nCount the number of rays that missed all geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Private-Functions","page":"Home","title":"Private Functions","text":"","category":"section"},{"location":"index.html#RayCaster.any_hit","page":"Home","title":"RayCaster.any_hit","text":"any_hit(bvh::BVHAccel, ray::AbstractRay)\n\nTest if a ray intersects any primitive in the BVH (without finding the closest hit). This function stops at the first intersection found, making it faster than closest_hit when you only need to know if there's an intersection.\n\nReturns:\n\nhit_found: Boolean indicating if any intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"function"},{"location":"index.html#RayCaster.closest_hit-Union{Tuple{P}, Tuple{RayCaster.BVHAccel{P}, RayCaster.AbstractRay}, Tuple{RayCaster.BVHAccel{P}, RayCaster.AbstractRay, Any}} where P","page":"Home","title":"RayCaster.closest_hit","text":"closest_hit(bvh::BVHAccel{P}, ray::AbstractRay) where {P}\n\nFind the closest intersection between a ray and the primitives stored in a BVH.\n\nReturns:\n\nhit_found: Boolean indicating if an intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}","page":"Home","title":"RayCaster.cos_θ","text":"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.\n\nSince normal is (0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.face_forward-Tuple{Any, Any}","page":"Home","title":"RayCaster.face_forward","text":"Flip normal n so that it lies in the same hemisphere as v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.generate_ray_grid-Tuple{RayCaster.BVHAccel, GeometryBasics.Vec{3, Float32}, Int64}","page":"Home","title":"RayCaster.generate_ray_grid","text":"generate_ray_grid(bvh::BVHAccel, ray_direction::Vec3f, grid_size::Int)\n\nGenerate a grid of ray origins based on the BVH bounding box and a given ray direction.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.intersect_p-Tuple{RayCaster.Bounds3, RayCaster.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}","page":"Home","title":"RayCaster.intersect_p","text":"dirisnegative: 1 – false, 2 – true\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.maximum_extent-Tuple{RayCaster.Bounds3}","page":"Home","title":"RayCaster.maximum_extent","text":"Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.\n\n1 - x, 2 - y, 3 - z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.offset-Tuple{RayCaster.Bounds3, GeometryBasics.Point{3, Float32}}","page":"Home","title":"RayCaster.offset","text":"Get offset of a point from the minimum point of the bounds.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}","page":"Home","title":"RayCaster.reflect","text":"Reflect wo about n.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.traverse_bvh-Union{Tuple{F}, Tuple{P}, Tuple{F, RayCaster.BVHAccel{P}, RayCaster.AbstractRay}, Tuple{F, RayCaster.BVHAccel{P}, RayCaster.AbstractRay, Any}} where {P, F<:Function}","page":"Home","title":"RayCaster.traverse_bvh","text":"traverse_bvh(bvh::BVHAccel{P}, ray::AbstractRay, hit_callback::F) where {P, F<:Function}\n\nInternal function that traverses the BVH to find ray-primitive intersections. Uses a callback pattern to handle different intersection behaviors.\n\nArguments:\n\nbvh: The BVH acceleration structure\nray: The ray to test for intersections\nhit_callback: Function called when primitive is tested. Signature:  hitcallback(primitive, ray) -> (continuetraversal::Bool, ray::AbstractRay, results::Any)\n\nReturns:\n\nThe final result from the hit_callback\n\n\n\n\n\n","category":"method"}]
}
