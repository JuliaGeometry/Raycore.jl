var documenterSearchIndex = {"docs":
[{"location":"raytracing_tutorial.html#Ray-Tracing-with-Raycore","page":"Ray Tracing Tutorial","title":"Ray Tracing with Raycore","text":"","category":"section"},{"location":"raytracing_tutorial.html","page":"Ray Tracing Tutorial","title":"Ray Tracing Tutorial","text":"using Bonito, BonitoBook, Raycore\nApp() do\n    path = normpath(joinpath(dirname(pathof(Raycore)), \"..\", \"docs\", \"src\", \"raytracing_tutorial_content.md\"))\n    BonitoBook.InlineBook(path)\nend","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Ray-Tracing-with-Raycore:-Building-a-Real-Ray-Tracer","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"In this tutorial, we'll build a simple but complete ray tracer from scratch using Raycore. We'll start with the absolute basics and progressively add features until we have a ray tracer that produces beautiful images with shadows and materials.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"By the end, you'll have a working ray tracer that can render complex scenes!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Setup","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Setup","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing Colors, ImageShow\nusing Makie  # For loading assets\nusing BenchmarkTools","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Ready to go! We have:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore for fast ray-triangle intersections\nGeometryBasics for geometry primitives\nColors and ImageShow for displaying rendered images","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-1:-Our-Scene-A-Playful-Cat","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 1: Our Scene - A Playful Cat","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's create a fun scene that we'll use throughout this tutorial. We'll load a cat model and place it in a simple room.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Load the cat model and rotate it to face the camera\ncat_mesh = Makie.loadasset(\"cat.obj\")\n# Rotate 150 degrees around Y axis so cat faces camera at an angle\nangle = deg2rad(150f0)\nrotation = Makie.Quaternionf(0, sin(angle/2), 0, cos(angle/2))\nrotated_coords = [rotation * Point3f(v) for v in coordinates(cat_mesh)]\n\n# Get bounding box and translate cat to sit on the floor\ncat_bbox = Rect3f(rotated_coords)\nfloor_y = -1.5f0\ncat_offset = Vec3f(0, floor_y - cat_bbox.origin[2], 0)  # Translate so bottom sits on floor\n\ncat_mesh = GeometryBasics.normal_mesh(\n    [v + cat_offset for v in rotated_coords],\n    faces(cat_mesh)\n)\n\n# Create a simple room: floor, back wall, and side wall\nfloor = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(10, 0.01, 10)))\nback_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, 8), Vec3f(10, 5, 0.01)))\nleft_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(0.01, 5, 10)))\n\n# Add a couple of spheres for visual interest (also on the floor)\nsphere1 = Tesselation(Sphere(Point3f(-2, -1.5 + 0.8, 2), 0.8f0), 64)\nsphere2 = Tesselation(Sphere(Point3f(2, -1.5 + 0.6, 1), 0.6f0), 64)\n\n# Build our BVH acceleration structure\nscene_geometry = [cat_mesh, floor, back_wall, left_wall, sphere1, sphere2]\nbvh = Raycore.BVHAccel(scene_geometry)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Scene created!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Cat model with triangulated geometry\nRoom geometry: 3 walls\n2 decorative spheres\nBVH built for fast ray traversal","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-2:-The-Simplest-Ray-Tracer-Binary-Hit-Detection","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 2: The Simplest Ray Tracer - Binary Hit Detection","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's start super simple: for each pixel, we shoot a ray and color it based on whether we hit something or not.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Trace helper - runs a callback for each pixel\nfunction trace(f, bvh; width=700, height=300, camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n               sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    # Precompute camera parameters\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    for y in 1:height, x in 1:width\n        # Generate camera ray\n        ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n        ndc_y = 1.0f0 - 2.0f0 * y / height\n        direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n        ray = Raycore.Ray(o=camera_pos, d=direction)\n\n        # Ray-scene intersection\n        hit_found, triangle, distance, bary_coords = Raycore.closest_hit(bvh, ray)\n\n        # Let the callback decide the color (pass sky_color for misses)\n        img[y, x] = hit_found ? f(triangle, distance, bary_coords, ray) : sky_color\n    end\n\n    return img\nend\n\n# Binary kernel - white if hit\nbinary_kernel(triangle, distance, bary_coords, ray) = RGB(1.0f0, 1.0f0, 1.0f0)\n\ntrace(binary_kernel, bvh, sky_color=RGB(0.0f0, 0.0f0, 0.0f0))","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Our first render! Pure silhouette - you can see the cat and spheres.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-3:-Adding-Depth-Distance-Based-Shading","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 3: Adding Depth - Distance-Based Shading","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's make it more interesting by coloring based on distance (depth map).","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function depth_kernel(triangle, distance, bary_coords, ray)\n    # Map distance to grayscale (closer = brighter)\n    normalized_depth = clamp(1.0f0 - (distance - 2.0f0) / 8.0f0, 0.0f0, 1.0f0)\n    RGB(normalized_depth, normalized_depth, normalized_depth)\nend\n\ntrace(depth_kernel, bvh)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Depth perception! Now we can see the 3D structure - closer objects are brighter.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-4:-Surface-Normals-The-Foundation-of-Lighting","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 4: Surface Normals - The Foundation of Lighting","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"To do proper lighting, we need surface normals. Let's compute and visualize them.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Helper to interpolate normals using barycentric coordinates\nfunction compute_normal(triangle, bary_coords)\n    n1, n2, n3 = triangle.normals\n    u, v, w = bary_coords\n    normalize(Vec3f(u * n1 + v * n2 + w * n3))\nend\n\nfunction normal_kernel(triangle, distance, bary_coords, ray)\n    normal = compute_normal(triangle, bary_coords)\n    # Map normal components [-1,1] to color [0,1]\n    RGB((normal .+ 1.0f0) ./ 2.0f0...)\nend\n\ntrace(normal_kernel, bvh)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Surface normals visualized! Each color channel represents a normal component:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Red = X direction\nGreen = Y direction\nBlue = Z direction","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-5:-Basic-Lighting-Diffuse-Shading","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 5: Basic Lighting - Diffuse Shading","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now we can add a light source and compute simple diffuse (Lambertian) shading!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"light_pos = Point3f(3, 4, -2)\nlight_intensity = 50.0f0\n\nfunction diffuse_kernel(triangle, distance, bary_coords, ray)\n    # Compute hit point and normal\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Light direction and distance\n    light_dir = light_pos - hit_point\n    light_distance = norm(light_dir)\n    light_dir = normalize(light_dir)\n\n    # Diffuse shading (Lambertian)\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Light attenuation (inverse square law)\n    attenuation = light_intensity / (light_distance * light_distance)\n    color = diffuse * attenuation\n\n    RGB(color, color, color)\nend\n\ntrace(diffuse_kernel, bvh)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let there be light! Our scene now has proper shading based on surface orientation.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-6:-Adding-Shadows-Shadow-Rays","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 6: Adding Shadows - Shadow Rays","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Time to add realism with shadows using Raycore's any_hit for fast occlusion testing.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"ambient = 0.1f0  # Ambient lighting to prevent pure black shadows\n\nfunction shadow_kernel(triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Light direction\n    light_dir = light_pos - hit_point\n    light_distance = norm(light_dir)\n    light_dir = normalize(light_dir)\n\n    # Diffuse shading\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Shadow ray - offset slightly to avoid self-intersection\n    shadow_ray_origin = hit_point + normal * 0.001f0\n    shadow_ray = Raycore.Ray(o=shadow_ray_origin, d=light_dir)\n\n    # Check if path to light is blocked\n    shadow_hit, _, shadow_dist, _ = Raycore.any_hit(bvh, shadow_ray)\n    in_shadow = shadow_hit && shadow_dist < light_distance\n\n    # Final color\n    color = if in_shadow\n        ambient  # Only ambient in shadow\n    else\n        attenuation = light_intensity / (light_distance * light_distance)\n        ambient + diffuse * attenuation\n    end\n\n    RGB(color, color, color)\nend\n\ntrace(shadow_kernel, bvh)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Shadows! Notice how objects cast shadows on each other, adding depth and realism.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-7:-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 7: Multiple Lights","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multiple lights to make the scene more interesting! We'll define a RenderContext to hold lights and materials:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Define a simple point light structure\nstruct PointLight\n    position::Point3f\n    intensity::Float32\n    color::RGB{Float32}\nend\n\n# Material structure (for later use)\nstruct Material\n    base_color::RGB{Float32}\n    metallic::Float32\n    roughness::Float32\nend\n\n# Render context holds all scene data\nstruct RenderContext\n    bvh::Raycore.BVHAccel\n    lights::Vector{PointLight}\n    materials::Vector{Material}\n    ambient::Float32\nend\n\n# Create multiple lights\nlights = [\n    PointLight(Point3f(3, 4, -2), 50.0f0, RGB(1.0f0, 0.9f0, 0.8f0)),    # Warm main light\n    PointLight(Point3f(-3, 2, 0), 20.0f0, RGB(0.7f0, 0.8f0, 1.0f0)),   # Cool fill light\n    PointLight(Point3f(0, 5, 5), 15.0f0, RGB(1.0f0, 1.0f0, 1.0f0))     # White back light\n]\n\n# Materials (will use these in Part 8)\nmaterials = [\n    Material(RGB(0.8f0, 0.6f0, 0.4f0), 0.0f0, 0.8f0),  # 1: Cat\n    Material(RGB(0.3f0, 0.5f0, 0.3f0), 0.0f0, 0.9f0),  # 2: Floor\n    Material(RGB(0.7f0, 0.7f0, 0.8f0), 0.0f0, 0.8f0),  # 3: Back wall\n    Material(RGB(0.8f0, 0.7f0, 0.7f0), 0.0f0, 0.8f0),  # 4: Left wall\n    Material(RGB(0.95f0, 0.64f0, 0.54f0), 1.0f0, 0.1f0),  # 5: Sphere 1 - metallic\n    Material(RGB(0.8f0, 0.8f0, 0.9f0), 1.0f0, 0.0f0)   # 6: Sphere 2 - mirror\n]\n\n# Create render context\nctx = RenderContext(bvh, lights, materials, 0.1f0)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now we need a new trace function that works with RenderContext:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Trace with RenderContext\nfunction trace_ctx(f, ctx::RenderContext; width=700, height=300,camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n                   sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    for y in 1:height, x in 1:width\n        ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n        ndc_y = 1.0f0 - 2.0f0 * y / height\n        direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n        ray = Raycore.Ray(o=camera_pos, d=direction)\n\n        hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n        img[y, x] = hit_found ? f(ctx, triangle, distance, bary_coords, ray) : sky_color\n    end\n\n    return img\nend\n\nfunction multi_light_kernel(ctx, triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Start with ambient (grayscale)\n    total_color = Vec3f(ctx.ambient, ctx.ambient, ctx.ambient)\n\n    # Accumulate contribution from each light\n    for light in ctx.lights\n        light_vec = light.position - hit_point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        shadow_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += light_col * (diffuse * attenuation)\n        end\n    end\n\n    RGB{Float32}(total_color...)\nend\n\ntrace_ctx(multi_light_kernel, ctx)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Multiple lights! The scene now has three different colored lights creating a more dynamic lighting environment.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-8:-Colored-Materials-with-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 8: Colored Materials with Multiple Lights","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now let's combine materials with our multiple lights!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function material_multi_light_kernel(ctx, triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Get material from context\n    mat = ctx.materials[triangle.material_idx]\n    base_color = Vec3f(mat.base_color.r, mat.base_color.g, mat.base_color.b)\n\n    # Start with ambient\n    total_color = base_color * ctx.ambient\n\n    # Accumulate contribution from each light\n    for light in ctx.lights\n        light_vec = light.position - hit_point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        # Shadow test\n        shadow_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += base_color .* light_col * (diffuse * attenuation)\n        end\n    end\n\n    RGB{Float32}(total_color...)\nend\n\ntrace_ctx(material_multi_light_kernel, ctx)","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Colored materials!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Orange/tan cat\nGreen floor\nLight blue back wall\nPink side wall\nRed and blue spheres","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-9:-Reflective-Materials-Mirrors-and-Metals","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 9: Reflective Materials - Mirrors and Metals","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"The materials we defined in Part 7 already have metallic and roughness properties. Let's use them for reflections!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Helper: compute direct lighting with multiple lights\nfunction compute_multi_light(ctx, point, normal, mat)\n    base_color = Vec3f(mat.base_color.r, mat.base_color.g, mat.base_color.b)\n\n    # Start with ambient\n    total_color = base_color * ctx.ambient\n\n    for light in ctx.lights\n        light_vec = light.position - point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        # Shadow test\n        shadow_ray = Raycore.Ray(o=point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += base_color .* light_col * (diffuse * attenuation)\n        end\n    end\n\n    return RGB{Float32}(total_color...)\nend\n\nfunction reflective_kernel(ctx, triangle, distance, bary_coords, ray, sky_color)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n    mat = ctx.materials[triangle.material_idx]\n\n    # Compute direct lighting (diffuse component)\n    direct_color = compute_multi_light(ctx, hit_point, normal, mat)\n\n    # Add reflection for metallic materials\n    if mat.metallic > 0.0f0\n        # Compute reflection direction: reflect outgoing direction about normal\n        # Note: ray.d points toward surface, but reflect() expects outgoing direction\n        wo = -ray.d  # outgoing direction (away from surface)\n        reflect_dir = Raycore.reflect(wo, normal)\n\n        # Add roughness by perturbing reflection direction\n        if mat.roughness > 0.0f0\n            # Simple roughness: add random offset in tangent space\n            random_offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * mat.roughness\n            reflect_dir = normalize(reflect_dir + random_offset)\n        end\n\n        # Cast reflection ray (offset to avoid self-intersection)\n        reflect_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=reflect_dir)\n        refl_hit, refl_tri, refl_dist, refl_bary = Raycore.closest_hit(ctx.bvh, reflect_ray)\n\n        # Get reflection color\n        reflection_color = if refl_hit\n            refl_point = reflect_ray.o + reflect_ray.d * refl_dist\n            refl_normal = compute_normal(refl_tri, refl_bary)\n            refl_mat = ctx.materials[refl_tri.material_idx]\n\n            # Compute lighting for reflected surface\n            compute_multi_light(ctx, refl_point, refl_normal, refl_mat)\n        else\n            sky_color\n        end\n\n        # Blend between diffuse and reflection based on metallic parameter\n        return direct_color * (1.0f0 - mat.metallic) + reflection_color * mat.metallic\n    else\n        # Pure diffuse material\n        return direct_color\n    end\nend\n\ntrace_ctx(ctx) do ctx, triangle, distance, bary_coords, ray\n    reflective_kernel(ctx, triangle, distance, bary_coords, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Reflective materials! The spheres now have metallic properties:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"One smooth copper-colored metal with slight roughness\nOne perfect mirror reflecting the scene","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Notice how reflections capture both the scene geometry and lighting!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-10:-Multi-threading-for-Performance","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 10: Multi-threading for Performance","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multi-threading to make our ray tracer much faster!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using BenchmarkTools\nfunction trace_ctx_threaded(f, ctx::RenderContext; width=400, height=300, camera_pos=Point3f(0, 1, -2.5), fov=45.0f0,\n                            sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n            ndc_y = 1.0f0 - 2.0f0 * y / height\n            direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n            ray = Raycore.Ray(o=camera_pos, d=direction)\n\n            hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n            img[y, x] = hit_found ? f(ctx, triangle, distance, bary_coords, ray) : sky_color\n        end\n    end\n\n    return img\nend\n\n# Benchmark single-threaded vs multi-threaded\nb1 = @belapsed trace_ctx(material_multi_light_kernel, ctx, width=800, height=600);\n\nb2 = @belapsed trace_ctx_threaded(material_multi_light_kernel, ctx, width=800, height=600);\nmd\"\"\"\nThreads: $(Threads.nthreads())\n\nSingle: $(b1)\n\nMulti: $(b2)\n\"\"\"","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Performance boost with threading! The speedup should be close to the number of CPU cores.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Notice how we can reuse the same kernel function with both trace_ctx() and trace_ctx_threaded() - this is great for composability!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Part-11:-Multi-Sampling-for-Anti-Aliasing","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 11: Multi-Sampling for Anti-Aliasing","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multiple samples per pixel with jittered camera rays for smooth anti-aliasing:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function trace_ctx_sampled(f, ctx::RenderContext; \n        width=700, height=300, \n        camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0, \n        sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0), \n        samples=4)\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n    pixel_size = 1.0f0 / width\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            # Accumulate multiple samples per pixel using Vec3f for math\n            color_sum = Vec3f(0.0f0, 0.0f0, 0.0f0)\n\n            for _ in 1:samples\n                jitter_x = (rand(Float32) - 0.5f0) * pixel_size\n                jitter_y = (rand(Float32) - 0.5f0) * pixel_size\n\n                ndc_x = (2.0f0 * (x + jitter_x) / width - 1.0f0) * aspect\n                ndc_y = 1.0f0 - 2.0f0 * (y + jitter_y) / height\n                direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n                ray = Raycore.Ray(o=camera_pos, d=direction)\n\n                hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n\n                color = if hit_found\n                    result = f(ctx, triangle, distance, bary_coords, ray)\n                    Vec3f(result.r, result.g, result.b)\n                else\n                    Vec3f(sky_color.r, sky_color.g, sky_color.b)\n                end\n\n                color_sum += color\n            end\n\n            # Average samples and convert back to RGB\n            avg = color_sum / samples\n            img[y, x] = RGB{Float32}(avg...)\n        end\n    end\n\n    return img\nend\n\n# Render with 16 samples per pixel for smooth anti-aliasing\n@time trace_ctx_sampled(ctx, samples=64) do ctx, triangle, distance, bary_coords, ray\n    reflective_kernel(ctx, triangle, distance, bary_coords, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Anti-aliased render! 32 samples per pixel with jittered camera rays eliminate jagged edges.","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Summary-What-We-Built","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Summary - What We Built","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"We created a complete ray tracer that includes:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Features-Implemented","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Features Implemented","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Camera system - Perspective projection with configurable FOV\nRay-scene intersection - Using Raycore's BVH for fast traversal\nSurface normals - Smooth shading from vertex normals\nDiffuse lighting - Lambertian shading with distance attenuation\nHard shadows - Using any_hit for efficient occlusion testing\nSimple materials - Per-object color assignment\nMulti-threading - Parallel rendering across CPU cores\nCallback-based API - Flexible trace() function for experimentation","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Next-Steps","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Next Steps","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"To make this into a full path tracer (like Trace), you would add:","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Recursive ray tracing - Reflections and refractions\nMultiple light sources - Area lights, environment lighting\nAdvanced materials - Specular, glossy, transparent\nSampling - Multiple samples per pixel for anti-aliasing\nBetter normal interpolation - Proper barycentric interpolation\nGPU support - Using KernelAbstractions.jl","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"The Trace package implements all of these features and more!","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html#Key-Raycore-Functions-Used","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Key Raycore Functions Used","text":"","category":"section"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore.BVHAccel(meshes) - Build acceleration structure\nRaycore.Ray(o=origin, d=direction) - Create ray\nRaycore.closest_hit(bvh, ray) - Find nearest intersection\nRaycore.any_hit(bvh, ray) - Test for any intersection (fast!)\nRaycore.vertices(triangle) - Get triangle vertex positions\nRaycore.normals(triangle) - Get triangle vertex normals","category":"page"},{"location":".raytracing_tutorial_content-bbook/.versions/raytracing_tutorial_content-2025-10-28_201849.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Happy ray tracing!","category":"page"},{"location":"bvh_hit_tests.html#BVH-Hit-Testing:-closest_hit-vs-any_hit","page":"BVH Hit Tests","title":"BVH Hit Testing: closest_hit vs any_hit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"This document tests and visualizes the difference between closest_hit and any_hit functions in the BVH implementation using the new RayIntersectionSession API.","category":"page"},{"location":"bvh_hit_tests.html#Test-Setup","page":"BVH Hit Tests","title":"Test Setup","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie\nusing Test\nusing Bonito\n\n# Create a simple test scene with multiple overlapping primitives\nfunction create_test_scene()\n    # Three spheres at different distances along the Z-axis\n    sphere1 = Tesselation(Sphere(Point3f(0, 0, 5), 1.0f0), 20)   # Furthest\n    sphere2 = Tesselation(Sphere(Point3f(0, 0, 3), 1.0f0), 20)   # Middle\n    sphere3 = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)   # Closest\n\n    bvh = Raycore.BVHAccel([sphere1, sphere2, sphere3])\n    return bvh\nend\n\nbvh = create_test_scene()\n\nDOM.div(\"✓ Created BVH with $(length(bvh.primitives)) triangles from 3 spheres\")","category":"page"},{"location":"bvh_hit_tests.html#Test-1:-Single-Ray-Through-Center","page":"BVH Hit Tests","title":"Test 1: Single Ray Through Center","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Test a ray through the center that passes through all three spheres.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(Raycore.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(Raycore.any_hit, [test_ray], bvh)\n\nfig = Figure()\n\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", fontsize=20, font=:bold, tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", fontsize=20, font=:bold, tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Single-Ray-with-Makie-Recipe","page":"BVH Hit Tests","title":"Visualization: Single Ray with Makie Recipe","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a ray with slight offset to avoid hitting triangle vertices exactly\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, 10), d=Vec3f(0, 0, -1))\n\n# Create session with closest_hit\nsession_closest = RayIntersectionSession(Raycore.closest_hit, [test_ray], bvh)\n\n# Create session with any_hit for comparison\nsession_any = RayIntersectionSession(Raycore.any_hit, [test_ray], bvh)\n\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig","category":"page"},{"location":"bvh_hit_tests.html#Test-2:-Multiple-Rays-from-Different-Positions","page":"BVH Hit Tests","title":"Test 2: Multiple Rays from Different Positions","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Test multiple rays to ensure both functions work correctly.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Test rays from different angles (with slight offset to avoid vertex hits)\ntest_positions = [\n    Point3f(0.1, 0.1, -5),      # Center\n    Point3f(0.5, 0.1, -5),      # Right offset\n    Point3f(0.1, 0.5, -5),      # Top offset\n    Point3f(-0.5, 0.1, -5),     # Left offset\n]\n\n# Create rays\nrays = [Raycore.Ray(o=pos, d=Vec3f(0, 0, 1)) for pos in test_positions]\n\n# Create session\nsession_multi = RayIntersectionSession(Raycore.closest_hit, rays, bvh)\nfig2 = Figure()\nax = LScene(fig2[1, 1])\n\n# Use different colors for each ray\nray_colors = [:purple, :orange, :cyan, :magenta]\n\nplot!(ax, session_multi;\n      show_bvh=true,\n      bvh_alpha=0.3,\n      ray_colors=ray_colors,\n      hit_color=:green,\n      show_hit_points=true,\n      hit_markersize=0.15,\n      show_labels=false)\n\nfig2","category":"page"},{"location":"bvh_hit_tests.html#Visualization:-Multiple-Rays","page":"BVH Hit Tests","title":"Visualization: Multiple Rays","text":"","category":"section"},{"location":"bvh_hit_tests.html#Test-4:-Difference-Between-any*hit-and-closest*hit","page":"BVH Hit Tests","title":"Test 4: Difference Between anyhit and closesthit","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Demonstrate that any_hit can return different results than closest_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"# Create a complex scene with overlapping geometry\n# This creates a BVH where traversal order can differ from distance order\nusing Random\nRandom.seed!(123)\n\ncomplex_spheres = []\n\n# Add some large overlapping spheres\npush!(complex_spheres, Tesselation(Sphere(Point3f(0, 0, 10), 3.0f0), 20))\npush!(complex_spheres, Tesselation(Sphere(Point3f(0.5, 0, 5), 0.5f0), 15))\npush!(complex_spheres, Tesselation(Sphere(Point3f(-0.5, 0, 15), 1.5f0), 18))\n\n# Add many small spheres to create complex BVH structure\nfor i in 1:30\n    x = randn() * 5\n    y = randn() * 5\n    z = rand(8.0:0.5:12.0)\n    r = 0.3 + rand() * 0.5\n    push!(complex_spheres, Tesselation(Sphere(Point3f(x, y, z), r), 8))\nend\n\ncomplex_bvh = Raycore.BVHAccel(complex_spheres)\n\n# Test rays to find cases where any_hit differs from closest_hit\ntest_rays = map(1:100) do i\n    x = (i % 10) * 0.4 - 2.0\n    y = div(i-1, 10) * 0.4 - 2.0\n    Raycore.Ray(o=Point3f(x, y, -5), d=Vec3f(0, 0, 1))\nend\n\nsession_closest = RayIntersectionSession(Raycore.closest_hit, test_rays, complex_bvh)\nsession_any = RayIntersectionSession(Raycore.any_hit, test_rays, complex_bvh)\nfig = Figure()\n# Left: closest_hit visualization\nplot(fig[1, 1], session_closest)\nplot(fig[1, 2], session_any)\nLabel(fig[0, 1], \"closest_hit\", tellwidth=false)\nLabel(fig[0, 2], \"any_hit\", tellwidth=false)\n\nfig\n","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Key Findings:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"any_hit exits on the first intersection during BVH traversal (uses intersect, doesn't update ray)\nclosest_hit continues searching and updates ray's t_max (uses intersect_p!)\nIn complex scenes with overlapping geometry, any_hit can return hits that are significantly farther\nBoth always agree on whether a hit occurred (hit vs miss)\nThe difference appears when BVH traversal order differs from spatial distance order","category":"page"},{"location":"bvh_hit_tests.html#Performance-Comparison","page":"BVH Hit Tests","title":"Performance Comparison","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"Compare the performance of closest_hit vs any_hit.","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"function render_io(obj)\n    io = IOBuffer()\n    show(io, MIME\"text/plain\"(), obj)\n    printer = BonitoBook.HTMLPrinter(io; root_tag = \"span\")\n    str = sprint(io -> show(io, MIME\"text/html\"(), printer))\n    DOM.pre(HTML(str); style=\"font-size: 10px\")\nend","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"using BenchmarkTools\n\ntest_ray = Raycore.Ray(o=Point3f(0.1, 0.1, -5), d=Vec3f(0, 0, 1))\n\n# Benchmark closest_hit\nclosest_time = @benchmark Raycore.closest_hit($bvh, $test_ray)\n\n# Benchmark any_hit\nany_time = @benchmark Raycore.any_hit($bvh, $test_ray)\n\n\nperf_table = map([\n    (\"closest_hit\", any_time),\n    (\"any_hit\", closest_time),\n]) do (method, time_us)\n    (Method = method, Time_μs = render_io(time_us))\nend\nBonito.Table(perf_table)","category":"page"},{"location":"bvh_hit_tests.html#Summary","page":"BVH Hit Tests","title":"Summary","text":"","category":"section"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"This document demonstrated:","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"RayIntersectionSession - A convenient struct for managing ray tracing sessions\nBundles rays, BVH, hit function, and results together\nProvides helper functions: hit_count(), miss_count(), hit_points(), hit_distances()\nMakie visualization recipe - Automatic visualization via plot(session)\nAutomatically renders BVH geometry, rays, and hit points\nCustomizable colors, transparency, markers, and labels\nWorks with any Makie backend (GLMakie, WGLMakie, CairoMakie)\nclosest_hit correctly identifies the nearest intersection among multiple overlapping primitives\nReturns: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\ndistance is the distance from ray origin to the hit point\nUse Raycore.sum_mul(bary_coords, primitive.vertices) to convert to world-space hit point\nany_hit efficiently determines if any intersection exists, exiting early\nReturns: Same format as closest_hit: (hit_found::Bool, hit_primitive::Triangle, distance::Float32, barycentric_coords::Point3f)\nCan exit early on first hit found, making it faster for occlusion testing\nBoth functions handle miss cases correctly (returning hit_found=false)\nany_hit is typically faster than closest_hit due to early termination","category":"page"},{"location":"bvh_hit_tests.html","page":"BVH Hit Tests","title":"BVH Hit Tests","text":"All tests passed! ✓","category":"page"},{"location":"raytracing_tutorial_content.html#Ray-Tracing-with-Raycore:-Building-a-Real-Ray-Tracer","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"In this tutorial, we'll build a simple but complete ray tracer from scratch using Raycore. We'll start with the absolute basics and progressively add features until we have a ray tracer that produces beautiful images with shadows and materials.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"By the end, you'll have a working ray tracer that can render complex scenes!","category":"page"},{"location":"raytracing_tutorial_content.html#Setup","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Setup","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing Colors, ImageShow\nusing Makie  # For loading assets\nusing BenchmarkTools","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Ready to go! We have:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore for fast ray-triangle intersections\nGeometryBasics for geometry primitives\nColors and ImageShow for displaying rendered images","category":"page"},{"location":"raytracing_tutorial_content.html#Part-1:-Our-Scene-A-Playful-Cat","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 1: Our Scene - A Playful Cat","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's create a fun scene that we'll use throughout this tutorial. We'll load a cat model and place it in a simple room.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Load the cat model and rotate it to face the camera\ncat_mesh = Makie.loadasset(\"cat.obj\")\n# Rotate 150 degrees around Y axis so cat faces camera at an angle\nangle = deg2rad(150f0)\nrotation = Makie.Quaternionf(0, sin(angle/2), 0, cos(angle/2))\nrotated_coords = [rotation * Point3f(v) for v in coordinates(cat_mesh)]\n\n# Get bounding box and translate cat to sit on the floor\ncat_bbox = Rect3f(rotated_coords)\nfloor_y = -1.5f0\ncat_offset = Vec3f(0, floor_y - cat_bbox.origin[2], 0)  # Translate so bottom sits on floor\n\ncat_mesh = GeometryBasics.normal_mesh(\n    [v + cat_offset for v in rotated_coords],\n    faces(cat_mesh)\n)\n\n# Create a simple room: floor, back wall, and side wall\nfloor = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(10, 0.01, 10)))\nback_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, 8), Vec3f(10, 5, 0.01)))\nleft_wall = normal_mesh(Rect3f(Vec3f(-5, -1.5, -2), Vec3f(0.01, 5, 10)))\n\n# Add a couple of spheres for visual interest (also on the floor)\nsphere1 = Tesselation(Sphere(Point3f(-2, -1.5 + 0.8, 2), 0.8f0), 64)\nsphere2 = Tesselation(Sphere(Point3f(2, -1.5 + 0.6, 1), 0.6f0), 64)\n\n# Build our BVH acceleration structure\nscene_geometry = [cat_mesh, floor, back_wall, left_wall, sphere1, sphere2]\nbvh = Raycore.BVHAccel(scene_geometry)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Scene created!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Cat model with triangulated geometry\nRoom geometry: 3 walls\n2 decorative spheres\nBVH built for fast ray traversal","category":"page"},{"location":"raytracing_tutorial_content.html#Part-2:-The-Simplest-Ray-Tracer-Binary-Hit-Detection","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 2: The Simplest Ray Tracer - Binary Hit Detection","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's start super simple: for each pixel, we shoot a ray and color it based on whether we hit something or not.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Trace helper - runs a callback for each pixel\nfunction trace(f, bvh; width=700, height=300, camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n               sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    # Precompute camera parameters\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    for y in 1:height, x in 1:width\n        # Generate camera ray\n        ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n        ndc_y = 1.0f0 - 2.0f0 * y / height\n        direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n        ray = Raycore.Ray(o=camera_pos, d=direction)\n\n        # Ray-scene intersection\n        hit_found, triangle, distance, bary_coords = Raycore.closest_hit(bvh, ray)\n\n        # Let the callback decide the color (pass sky_color for misses)\n        img[y, x] = hit_found ? f(triangle, distance, bary_coords, ray) : sky_color\n    end\n\n    return img\nend\n\n# Binary kernel - white if hit\nbinary_kernel(triangle, distance, bary_coords, ray) = RGB(1.0f0, 1.0f0, 1.0f0)\n\ntrace(binary_kernel, bvh, sky_color=RGB(0.0f0, 0.0f0, 0.0f0))","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Our first render! Pure silhouette - you can see the cat and spheres.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-3:-Adding-Depth-Distance-Based-Shading","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 3: Adding Depth - Distance-Based Shading","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's make it more interesting by coloring based on distance (depth map).","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function depth_kernel(triangle, distance, bary_coords, ray)\n    # Map distance to grayscale (closer = brighter)\n    normalized_depth = clamp(1.0f0 - (distance - 2.0f0) / 8.0f0, 0.0f0, 1.0f0)\n    RGB(normalized_depth, normalized_depth, normalized_depth)\nend\n\ntrace(depth_kernel, bvh)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Depth perception! Now we can see the 3D structure - closer objects are brighter.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-4:-Surface-Normals-The-Foundation-of-Lighting","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 4: Surface Normals - The Foundation of Lighting","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"To do proper lighting, we need surface normals. Let's compute and visualize them.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Helper to interpolate normals using barycentric coordinates\nfunction compute_normal(triangle, bary_coords)\n    n1, n2, n3 = triangle.normals\n    u, v, w = bary_coords\n    normalize(Vec3f(u * n1 + v * n2 + w * n3))\nend\n\nfunction normal_kernel(triangle, distance, bary_coords, ray)\n    normal = compute_normal(triangle, bary_coords)\n    # Map normal components [-1,1] to color [0,1]\n    RGB((normal .+ 1.0f0) ./ 2.0f0...)\nend\n\ntrace(normal_kernel, bvh)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Surface normals visualized! Each color channel represents a normal component:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Red = X direction\nGreen = Y direction\nBlue = Z direction","category":"page"},{"location":"raytracing_tutorial_content.html#Part-5:-Basic-Lighting-Diffuse-Shading","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 5: Basic Lighting - Diffuse Shading","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now we can add a light source and compute simple diffuse (Lambertian) shading!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"light_pos = Point3f(3, 4, -2)\nlight_intensity = 50.0f0\n\nfunction diffuse_kernel(triangle, distance, bary_coords, ray)\n    # Compute hit point and normal\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Light direction and distance\n    light_dir = light_pos - hit_point\n    light_distance = norm(light_dir)\n    light_dir = normalize(light_dir)\n\n    # Diffuse shading (Lambertian)\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Light attenuation (inverse square law)\n    attenuation = light_intensity / (light_distance * light_distance)\n    color = diffuse * attenuation\n\n    RGB(color, color, color)\nend\n\ntrace(diffuse_kernel, bvh)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let there be light! Our scene now has proper shading based on surface orientation.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-6:-Adding-Shadows-Shadow-Rays","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 6: Adding Shadows - Shadow Rays","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Time to add realism with shadows using Raycore's any_hit for fast occlusion testing.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"ambient = 0.1f0  # Ambient lighting to prevent pure black shadows\n\nfunction shadow_kernel(triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Light direction\n    light_dir = light_pos - hit_point\n    light_distance = norm(light_dir)\n    light_dir = normalize(light_dir)\n\n    # Diffuse shading\n    diffuse = max(0.0f0, dot(normal, light_dir))\n\n    # Shadow ray - offset slightly to avoid self-intersection\n    shadow_ray_origin = hit_point + normal * 0.001f0\n    shadow_ray = Raycore.Ray(o=shadow_ray_origin, d=light_dir)\n\n    # Check if path to light is blocked\n    shadow_hit, _, shadow_dist, _ = Raycore.any_hit(bvh, shadow_ray)\n    in_shadow = shadow_hit && shadow_dist < light_distance\n\n    # Final color\n    color = if in_shadow\n        ambient  # Only ambient in shadow\n    else\n        attenuation = light_intensity / (light_distance * light_distance)\n        ambient + diffuse * attenuation\n    end\n\n    RGB(color, color, color)\nend\n\ntrace(shadow_kernel, bvh)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Shadows! Notice how objects cast shadows on each other, adding depth and realism.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-7:-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 7: Multiple Lights","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multiple lights to make the scene more interesting! We'll define a RenderContext to hold lights and materials:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Define a simple point light structure\nstruct PointLight\n    position::Point3f\n    intensity::Float32\n    color::RGB{Float32}\nend\n\n# Material structure (for later use)\nstruct Material\n    base_color::RGB{Float32}\n    metallic::Float32\n    roughness::Float32\nend\n\n# Render context holds all scene data\nstruct RenderContext\n    bvh::Raycore.BVHAccel\n    lights::Vector{PointLight}\n    materials::Vector{Material}\n    ambient::Float32\nend\n\n# Create multiple lights\nlights = [\n    PointLight(Point3f(3, 4, -2), 50.0f0, RGB(1.0f0, 0.9f0, 0.8f0)),    # Warm main light\n    PointLight(Point3f(-3, 2, 0), 20.0f0, RGB(0.7f0, 0.8f0, 1.0f0)),   # Cool fill light\n    PointLight(Point3f(0, 5, 5), 15.0f0, RGB(1.0f0, 1.0f0, 1.0f0))     # White back light\n]\n\n# Materials (will use these in Part 8)\nmaterials = [\n    Material(RGB(0.8f0, 0.6f0, 0.4f0), 0.0f0, 0.8f0),  # 1: Cat\n    Material(RGB(0.3f0, 0.5f0, 0.3f0), 0.0f0, 0.9f0),  # 2: Floor\n    Material(RGB(0.7f0, 0.7f0, 0.8f0), 0.0f0, 0.8f0),  # 3: Back wall\n    Material(RGB(0.8f0, 0.7f0, 0.7f0), 0.0f0, 0.8f0),  # 4: Left wall\n    Material(RGB(0.95f0, 0.64f0, 0.54f0), 1.0f0, 0.1f0),  # 5: Sphere 1 - metallic\n    Material(RGB(0.8f0, 0.8f0, 0.9f0), 1.0f0, 0.0f0)   # 6: Sphere 2 - mirror\n]\n\n# Create render context\nctx = RenderContext(bvh, lights, materials, 0.1f0)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now we need a new trace function that works with RenderContext:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Trace with RenderContext\nfunction trace_ctx(f, ctx::RenderContext; width=700, height=300,camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0,\n                   sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    for y in 1:height, x in 1:width\n        ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n        ndc_y = 1.0f0 - 2.0f0 * y / height\n        direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n        ray = Raycore.Ray(o=camera_pos, d=direction)\n\n        hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n        img[y, x] = hit_found ? f(ctx, triangle, distance, bary_coords, ray) : sky_color\n    end\n\n    return img\nend\n\nfunction multi_light_kernel(ctx, triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Start with ambient (grayscale)\n    total_color = Vec3f(ctx.ambient, ctx.ambient, ctx.ambient)\n\n    # Accumulate contribution from each light\n    for light in ctx.lights\n        light_vec = light.position - hit_point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        shadow_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += light_col * (diffuse * attenuation)\n        end\n    end\n\n    RGB{Float32}(total_color...)\nend\n\ntrace_ctx(multi_light_kernel, ctx)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Multiple lights! The scene now has three different colored lights creating a more dynamic lighting environment.","category":"page"},{"location":"raytracing_tutorial_content.html#Part-8:-Colored-Materials-with-Multiple-Lights","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 8: Colored Materials with Multiple Lights","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Now let's combine materials with our multiple lights!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function material_multi_light_kernel(ctx, triangle, distance, bary_coords, ray)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n\n    # Get material from context\n    mat = ctx.materials[triangle.material_idx]\n    base_color = Vec3f(mat.base_color.r, mat.base_color.g, mat.base_color.b)\n\n    # Start with ambient\n    total_color = base_color * ctx.ambient\n\n    # Accumulate contribution from each light\n    for light in ctx.lights\n        light_vec = light.position - hit_point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        # Shadow test\n        shadow_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += base_color .* light_col * (diffuse * attenuation)\n        end\n    end\n\n    RGB{Float32}(total_color...)\nend\n\ntrace_ctx(material_multi_light_kernel, ctx)","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Colored materials!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Orange/tan cat\nGreen floor\nLight blue back wall\nPink side wall\nRed and blue spheres","category":"page"},{"location":"raytracing_tutorial_content.html#Part-9:-Reflective-Materials-Mirrors-and-Metals","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 9: Reflective Materials - Mirrors and Metals","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"The materials we defined in Part 7 already have metallic and roughness properties. Let's use them for reflections!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"# Helper: compute direct lighting with multiple lights\nfunction compute_multi_light(ctx, point, normal, mat)\n    base_color = Vec3f(mat.base_color.r, mat.base_color.g, mat.base_color.b)\n\n    # Start with ambient\n    total_color = base_color * ctx.ambient\n\n    for light in ctx.lights\n        light_vec = light.position - point\n        light_distance = norm(light_vec)\n        light_dir = light_vec / light_distance\n\n        diffuse = max(0.0f0, dot(normal, light_dir))\n\n        # Shadow test\n        shadow_ray = Raycore.Ray(o=point + normal * 0.001f0, d=light_dir)\n        shadow_hit, _, shadow_dist, _ = Raycore.any_hit(ctx.bvh, shadow_ray)\n        in_shadow = shadow_hit && shadow_dist < light_distance\n\n        if !in_shadow\n            attenuation = light.intensity / (light_distance * light_distance)\n            light_col = Vec3f(light.color.r, light.color.g, light.color.b)\n            total_color += base_color .* light_col * (diffuse * attenuation)\n        end\n    end\n\n    return RGB{Float32}(total_color...)\nend\n\nfunction reflective_kernel(ctx, triangle, distance, bary_coords, ray, sky_color)\n    hit_point = ray.o + ray.d * distance\n    normal = compute_normal(triangle, bary_coords)\n    mat = ctx.materials[triangle.material_idx]\n\n    # Compute direct lighting (diffuse component)\n    direct_color = compute_multi_light(ctx, hit_point, normal, mat)\n\n    # Add reflection for metallic materials\n    if mat.metallic > 0.0f0\n        # Compute reflection direction: reflect outgoing direction about normal\n        # Note: ray.d points toward surface, but reflect() expects outgoing direction\n        wo = -ray.d  # outgoing direction (away from surface)\n        reflect_dir = Raycore.reflect(wo, normal)\n\n        # Add roughness by perturbing reflection direction\n        if mat.roughness > 0.0f0\n            # Simple roughness: add random offset in tangent space\n            random_offset = (rand(Vec3f) .* 2.0f0 .- 1.0f0) * mat.roughness\n            reflect_dir = normalize(reflect_dir + random_offset)\n        end\n\n        # Cast reflection ray (offset to avoid self-intersection)\n        reflect_ray = Raycore.Ray(o=hit_point + normal * 0.001f0, d=reflect_dir)\n        refl_hit, refl_tri, refl_dist, refl_bary = Raycore.closest_hit(ctx.bvh, reflect_ray)\n\n        # Get reflection color\n        reflection_color = if refl_hit\n            refl_point = reflect_ray.o + reflect_ray.d * refl_dist\n            refl_normal = compute_normal(refl_tri, refl_bary)\n            refl_mat = ctx.materials[refl_tri.material_idx]\n\n            # Compute lighting for reflected surface\n            compute_multi_light(ctx, refl_point, refl_normal, refl_mat)\n        else\n            sky_color\n        end\n\n        # Blend between diffuse and reflection based on metallic parameter\n        return direct_color * (1.0f0 - mat.metallic) + reflection_color * mat.metallic\n    else\n        # Pure diffuse material\n        return direct_color\n    end\nend\n\ntrace_ctx(ctx) do ctx, triangle, distance, bary_coords, ray\n    reflective_kernel(ctx, triangle, distance, bary_coords, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Reflective materials! The spheres now have metallic properties:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"One smooth copper-colored metal with slight roughness\nOne perfect mirror reflecting the scene","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Notice how reflections capture both the scene geometry and lighting!","category":"page"},{"location":"raytracing_tutorial_content.html#Part-10:-Multi-threading-for-Performance","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 10: Multi-threading for Performance","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multi-threading to make our ray tracer much faster!","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"using BenchmarkTools\nfunction trace_ctx_threaded(f, ctx::RenderContext; width=400, height=300, camera_pos=Point3f(0, 1, -2.5), fov=45.0f0,\n                            sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0))\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            ndc_x = (2.0f0 * x / width - 1.0f0) * aspect\n            ndc_y = 1.0f0 - 2.0f0 * y / height\n            direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n            ray = Raycore.Ray(o=camera_pos, d=direction)\n\n            hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n            img[y, x] = hit_found ? f(ctx, triangle, distance, bary_coords, ray) : sky_color\n        end\n    end\n\n    return img\nend\n\n# Benchmark single-threaded vs multi-threaded\nb1 = @belapsed trace_ctx(material_multi_light_kernel, ctx, width=800, height=600);\n\nb2 = @belapsed trace_ctx_threaded(material_multi_light_kernel, ctx, width=800, height=600);\nmd\"\"\"\nThreads: $(Threads.nthreads())\n\nSingle: $(b1)\n\nMulti: $(b2)\n\"\"\"","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Performance boost with threading! The speedup should be close to the number of CPU cores.","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Notice how we can reuse the same kernel function with both trace_ctx() and trace_ctx_threaded() - this is great for composability!","category":"page"},{"location":"raytracing_tutorial_content.html#Part-11:-Multi-Sampling-for-Anti-Aliasing","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Part 11: Multi-Sampling for Anti-Aliasing","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Let's add multiple samples per pixel with jittered camera rays for smooth anti-aliasing:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"function trace_ctx_sampled(f, ctx::RenderContext; \n        width=700, height=300, \n        camera_pos=Point3f(0, -0.9, -2.5), fov=45.0f0, \n        sky_color=RGB{Float32}(0.5f0, 0.7f0, 1.0f0), \n        samples=4)\n    img = Matrix{RGB{Float32}}(undef, height, width)\n\n    aspect = Float32(width / height)\n    focal_length = 1.0f0 / tan(deg2rad(fov / 2))\n    pixel_size = 1.0f0 / width\n\n    Threads.@threads for y in 1:height\n        for x in 1:width\n            # Accumulate multiple samples per pixel using Vec3f for math\n            color_sum = Vec3f(0.0f0, 0.0f0, 0.0f0)\n\n            for _ in 1:samples\n                jitter_x = (rand(Float32) - 0.5f0) * pixel_size\n                jitter_y = (rand(Float32) - 0.5f0) * pixel_size\n\n                ndc_x = (2.0f0 * (x + jitter_x) / width - 1.0f0) * aspect\n                ndc_y = 1.0f0 - 2.0f0 * (y + jitter_y) / height\n                direction = normalize(Vec3f(ndc_x, ndc_y, focal_length))\n                ray = Raycore.Ray(o=camera_pos, d=direction)\n\n                hit_found, triangle, distance, bary_coords = Raycore.closest_hit(ctx.bvh, ray)\n\n                color = if hit_found\n                    result = f(ctx, triangle, distance, bary_coords, ray)\n                    Vec3f(result.r, result.g, result.b)\n                else\n                    Vec3f(sky_color.r, sky_color.g, sky_color.b)\n                end\n\n                color_sum += color\n            end\n\n            # Average samples and convert back to RGB\n            avg = color_sum / samples\n            img[y, x] = RGB{Float32}(avg...)\n        end\n    end\n\n    return img\nend\n\n# Render with 16 samples per pixel for smooth anti-aliasing\n@time trace_ctx_sampled(ctx, samples=64) do ctx, triangle, distance, bary_coords, ray\n    reflective_kernel(ctx, triangle, distance, bary_coords, ray, RGB(0.5f0, 0.7f0, 1.0f0))\nend","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Anti-aliased render! 32 samples per pixel with jittered camera rays eliminate jagged edges.","category":"page"},{"location":"raytracing_tutorial_content.html#Summary-What-We-Built","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Summary - What We Built","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"We created a complete ray tracer that includes:","category":"page"},{"location":"raytracing_tutorial_content.html#Features-Implemented","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Features Implemented","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Camera system - Perspective projection with configurable FOV\nRay-scene intersection - Using Raycore's BVH for fast traversal\nSurface normals - Smooth shading from vertex normals\nDiffuse lighting - Lambertian shading with distance attenuation\nHard shadows - Using any_hit for efficient occlusion testing\nSimple materials - Per-object color assignment\nMulti-threading - Parallel rendering across CPU cores\nCallback-based API - Flexible trace() function for experimentation","category":"page"},{"location":"raytracing_tutorial_content.html#Next-Steps","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Next Steps","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"To make this into a full path tracer (like Trace), you would add:","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Recursive ray tracing - Reflections and refractions\nMultiple light sources - Area lights, environment lighting\nAdvanced materials - Specular, glossy, transparent\nSampling - Multiple samples per pixel for anti-aliasing\nBetter normal interpolation - Proper barycentric interpolation\nGPU support - Using KernelAbstractions.jl","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"The Trace package implements all of these features and more!","category":"page"},{"location":"raytracing_tutorial_content.html#Key-Raycore-Functions-Used","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Key Raycore Functions Used","text":"","category":"section"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Raycore.BVHAccel(meshes) - Build acceleration structure\nRaycore.Ray(o=origin, d=direction) - Create ray\nRaycore.closest_hit(bvh, ray) - Find nearest intersection\nRaycore.any_hit(bvh, ray) - Test for any intersection (fast!)\nRaycore.vertices(triangle) - Get triangle vertex positions\nRaycore.normals(triangle) - Get triangle vertex normals","category":"page"},{"location":"raytracing_tutorial_content.html","page":"Ray Tracing with Raycore: Building a Real Ray Tracer","title":"Ray Tracing with Raycore: Building a Real Ray Tracer","text":"Happy ray tracing!","category":"page"},{"location":"index.html#Raycore.jl","page":"Home","title":"Raycore.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Raycore, GeometryBasics, LinearAlgebra\nusing WGLMakie, FileIO\n\nfunction LowSphere(radius, contact=Point3f(0); ntriangles=10)\n    return Tesselation(Sphere(contact .+ Point3f(0, 0, radius), radius), ntriangles)\nend\n\nntriangles = 10\ns1 = LowSphere(0.5f0, Point3f(-0.5, 0.0, 0); ntriangles)\ns2 = LowSphere(0.3f0, Point3f(1, 0.5, 0); ntriangles)\ns3 = LowSphere(0.3f0, Point3f(-0.5, 1, 0); ntriangles)\ns4 = LowSphere(0.4f0, Point3f(0, 1.0, 0); ntriangles)\nl = 0.5\nfloor = Rect3f(-l, -l, -0.01, 2l, 2l, 0.01)\ncat = load(Makie.assetpath(\"cat.obj\"))\nbvh = Raycore.BVHAccel([s1, s2, s3, s4, cat]);\nworld_mesh = GeometryBasics.Mesh(bvh)\nf, ax, pl = Makie.mesh(world_mesh; color=:teal)\ncenter!(ax.scene)\nviewdir = normalize(ax.scene.camera.view_direction[])\n\n@time \"hitpoints\" hitpoints, centroid = Raycore.get_centroid(bvh, viewdir)\n@time \"illum\" illum = Raycore.get_illumination(bvh, viewdir)\n@time \"viewf_matrix\" viewf_matrix = Raycore.view_factors(bvh, rays_per_triangle=1000)\nviewfacts = map(i-> Float32(sum(view(viewf_matrix, :, i))), 1:length(bvh.primitives))\nworld_mesh = GeometryBasics.Mesh(bvh)\nN = length(world_mesh.faces)\nareas = map(i-> area(world_mesh.position[world_mesh.faces[i]]), 1:N)\n# View factors\nf, ax, pl = mesh(world_mesh, color=:teal, figure=(; size=(800, 600)), axis=(; show_axis=false))\nper_face_vf = FaceView((viewfacts), [GLTriangleFace(i) for i in 1:N])\nviewfact_mesh = GeometryBasics.mesh(world_mesh, color=per_face_vf)\npl = Makie.mesh(f[1, 2],\n    viewfact_mesh, colormap=[:black, :red], axis=(; show_axis=false),\n    shading=false, highclip=:red, lowclip=:black, colorscale=sqrt,)\n\n# Centroid\ncax, pl = Makie.mesh(f[2, 1], world_mesh, color=(:blue, 0.5), axis=(; show_axis=false), transparency=true)\n\neyepos = cax.scene.camera.eyeposition[]\ndepth = map(x-> norm(x .- eyepos), hitpoints)\nmeshscatter!(cax, hitpoints, color=depth, colormap=[:gray, :black], markersize=0.01)\nmeshscatter!(cax, centroid, color=:red, markersize=0.05)\n\n# Illum\npf = FaceView(100f0 .* (illum ./ areas), [GLTriangleFace(i) for i in 1:N])\nillum_mesh = GeometryBasics.mesh(world_mesh, color=pf)\n\nMakie.mesh(f[2, 2], illum_mesh, colormap=[:black, :yellow], colorscale=sqrt, shading=false, axis=(; show_axis=false))\n\nLabel(f[0, 1], \"Scene ($(length(bvh.primitives)) triangles)\", tellwidth=false, fontsize=20)\nLabel(f[0, 2], \"Viewfactors\", tellwidth=false, fontsize=20)\nLabel(f[3, 1], \"Centroid\", tellwidth=false, fontsize=20)\nLabel(f[3, 2], \"Illumination\", tellwidth=false, fontsize=20)\n\nf","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Bonito, BonitoBook\nApp() do\n    path = normpath(joinpath(dirname(pathof(Raycore)), \"..\", \"docs\", \"src\", \"bvh_hit_tests.md\"))\n    BonitoBook.InlineBook(path)\nend","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#Raycore.RayIntersectionSession","page":"Home","title":"Raycore.RayIntersectionSession","text":"RayIntersectionSession{F}\n\nRepresents a ray tracing session containing rays, a BVH structure, a hit function, and the computed intersection results.\n\nFields\n\nrays::Vector{<:AbstractRay}: Array of rays to trace\nbvh::BVHAccel: BVH acceleration structure to intersect against\nhit_function::F: Function to use for intersection testing (e.g., closest_hit or any_hit)\nhits::Vector{Tuple{Bool, Triangle, Float32, Point3f}}: Results of hit_function applied to each ray\n\nExample\n\nusing Raycore, GeometryBasics\n\n# Create BVH from geometry\nsphere = Tesselation(Sphere(Point3f(0, 0, 1), 1.0f0), 20)\nbvh = Raycore.BVHAccel([sphere])\n\n# Create rays\nrays = [\n    Raycore.Ray(Point3f(0, 0, -5), Vec3f(0, 0, 1)),\n    Raycore.Ray(Point3f(1, 0, -5), Vec3f(0, 0, 1)),\n]\n\n# Create session\nsession = RayIntersectionSession(rays, bvh, Raycore.closest_hit)\n\n# Access results\nfor (i, hit) in enumerate(session.hits)\n    hit_found, primitive, distance, bary_coords = hit\n    if hit_found\n        println(\"Ray $i hit at distance $distance\")\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"index.html#Raycore.hit_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_count","text":"hit_count(session::RayIntersectionSession)\n\nCount the number of rays that hit geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_distances-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_distances","text":"hit_distances(session::RayIntersectionSession)\n\nExtract all hit distances from a RayIntersectionSession.\n\nReturns a vector of Float32 containing distances for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.hit_points-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.hit_points","text":"hit_points(session::RayIntersectionSession)\n\nExtract all valid hit points from a RayIntersectionSession.\n\nReturns a vector of Point3f containing the world-space hit points for all rays that intersected geometry.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.miss_count-Tuple{RayIntersectionSession}","page":"Home","title":"Raycore.miss_count","text":"miss_count(session::RayIntersectionSession)\n\nCount the number of rays that missed all geometry in the session.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Private-Functions","page":"Home","title":"Private Functions","text":"","category":"section"},{"location":"index.html#Raycore.any_hit","page":"Home","title":"Raycore.any_hit","text":"any_hit(bvh::BVHAccel, ray::AbstractRay)\n\nTest if a ray intersects any primitive in the BVH (without finding the closest hit). This function stops at the first intersection found, making it faster than closest_hit when you only need to know if there's an intersection.\n\nReturns:\n\nhit_found: Boolean indicating if any intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"function"},{"location":"index.html#Raycore.closest_hit-Union{Tuple{P}, Tuple{Raycore.BVHAccel{P}, Raycore.AbstractRay}, Tuple{Raycore.BVHAccel{P}, Raycore.AbstractRay, Any}} where P","page":"Home","title":"Raycore.closest_hit","text":"closest_hit(bvh::BVHAccel{P}, ray::AbstractRay) where {P}\n\nFind the closest intersection between a ray and the primitives stored in a BVH.\n\nReturns:\n\nhit_found: Boolean indicating if an intersection was found\nhit_primitive: The primitive that was hit (if any)\ndistance: Distance along the ray to the hit point (hit_point = ray.o + ray.d * distance)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.cos_θ","text":"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.\n\nSince normal is (0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.face_forward-Tuple{Any, Any}","page":"Home","title":"Raycore.face_forward","text":"Flip normal n so that it lies in the same hemisphere as v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.generate_ray_grid-Tuple{Raycore.BVHAccel, GeometryBasics.Vec{3, Float32}, Int64}","page":"Home","title":"Raycore.generate_ray_grid","text":"generate_ray_grid(bvh::BVHAccel, ray_direction::Vec3f, grid_size::Int)\n\nGenerate a grid of ray origins based on the BVH bounding box and a given ray direction.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.intersect_p-Tuple{Raycore.Bounds3, Raycore.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}","page":"Home","title":"Raycore.intersect_p","text":"dirisnegative: 1 – false, 2 – true\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.maximum_extent-Tuple{Raycore.Bounds3}","page":"Home","title":"Raycore.maximum_extent","text":"Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.\n\n1 - x, 2 - y, 3 - z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.offset-Tuple{Raycore.Bounds3, GeometryBasics.Point{3, Float32}}","page":"Home","title":"Raycore.offset","text":"Get offset of a point from the minimum point of the bounds.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}","page":"Home","title":"Raycore.reflect","text":"Reflect wo about n.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Raycore.traverse_bvh-Union{Tuple{F}, Tuple{P}, Tuple{F, Raycore.BVHAccel{P}, Raycore.AbstractRay}, Tuple{F, Raycore.BVHAccel{P}, Raycore.AbstractRay, Any}} where {P, F<:Function}","page":"Home","title":"Raycore.traverse_bvh","text":"traverse_bvh(bvh::BVHAccel{P}, ray::AbstractRay, hit_callback::F) where {P, F<:Function}\n\nInternal function that traverses the BVH to find ray-primitive intersections. Uses a callback pattern to handle different intersection behaviors.\n\nArguments:\n\nbvh: The BVH acceleration structure\nray: The ray to test for intersections\nhit_callback: Function called when primitive is tested. Signature:  hitcallback(primitive, ray) -> (continuetraversal::Bool, ray::AbstractRay, results::Any)\n\nReturns:\n\nThe final result from the hit_callback\n\n\n\n\n\n","category":"method"}]
}
